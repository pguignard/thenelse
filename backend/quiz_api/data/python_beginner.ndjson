{"language": "Python", "level": "BEGINNER", "theme": "Listes", "snippet": "notes = [12, 15, 9, 14]\nprint(notes[2])", "choices": ["9", "12", "14", "15"], "answer_id": 0, "explanation": "Le code cr\u00e9e une liste `notes` contenant quatre \u00e9l\u00e9ments. En Python, l'indexation des listes commence \u00e0 0, donc `notes[0]` vaut 12, `notes[1]` vaut 15, et `notes[2]` vaut 9. Le print affiche donc la valeur \u00e0 l'index 2, qui est 9.\n\nL'indexation des listes en Python est bas\u00e9e sur un syst\u00e8me z\u00e9ro-index\u00e9, ce qui signifie que le premier \u00e9l\u00e9ment a l'index 0. Cette propri\u00e9t\u00e9 est fondamentale dans la manipulation des listes, car elle permet un acc\u00e8s direct et rapide \u00e0 un \u00e9l\u00e9ment en utilisant un entier repr\u00e9sentant sa position."}
{"language": "Python", "level": "BEGINNER", "theme": "Listes", "snippet": "produits = ['pain', 'lait', 'oeufs', 'beurre']\nprint(produits[-1])", "choices": ["beurre", "pain", "oeufs", "IndexError"], "answer_id": 0, "explanation": "La liste `produits` contient quatre \u00e9l\u00e9ments. En Python, les index n\u00e9gatifs acc\u00e8dent aux \u00e9l\u00e9ments depuis la fin de la liste. Ainsi, `produits[-1]` revient au dernier \u00e9l\u00e9ment de la liste, ici 'beurre'.\n\nLes index n\u00e9gatifs sont une fonctionnalit\u00e9 pratique pour r\u00e9cup\u00e9rer ais\u00e9ment les derniers \u00e9l\u00e9ments d'une liste sans conna\u00eetre sa longueur. Cela simplifie les op\u00e9rations sur les s\u00e9quences o\u00f9 la fin est d'int\u00e9r\u00eat principal."}
{"language": "Python", "level": "BEGINNER", "theme": "Listes", "snippet": "valeurs = [10, 20, 30, 40, 50]\nprint(valeurs[1:4])", "choices": ["[20, 30, 40]", "[10, 20, 30]", "[20, 30, 40, 50]", "[30, 40]"], "answer_id": 0, "explanation": "Le slicing `valeurs[1:4]` r\u00e9cup\u00e8re une sous-liste de `valeurs` \u00e0 partir de l'index 1 inclus jusqu'\u00e0 l'index 4 exclu. Cela correspond donc aux \u00e9l\u00e9ments aux positions 1, 2 et 3 : 20, 30, 40.\n\nLe slicing est une technique pour extraire une portion d'une liste ou d'une s\u00e9quence. La syntaxe `[d\u00e9but:fin]` inclut l'\u00e9l\u00e9ment \u00e0 l'index `d\u00e9but` mais exclut celui \u00e0 l'index `fin`. Cette manipulation se r\u00e9v\u00e8le essentielle pour travailler efficacement avec des s\u00e9quences en Python."}
{"language": "Python", "level": "BEGINNER", "theme": "Listes", "snippet": "ventes = [100, 150, 130]\nventes.append(200)\nprint(len(ventes))", "choices": ["4", "3", "200", "TypeError"], "answer_id": 0, "explanation": "Le code initialise une liste `ventes` avec trois \u00e9l\u00e9ments. Ensuite, la m\u00e9thode `append` ajoute l'\u00e9l\u00e9ment 200 \u00e0 la fin de la liste. Donc la liste contient maintenant quatre \u00e9l\u00e9ments. La fonction `len()` retourne la longueur de la liste, soit 4.\n\nLa m\u00e9thode `append` est utilis\u00e9e pour ajouter un \u00e9l\u00e9ment \u00e0 la fin d'une liste en Python. C'est une des m\u00e9thodes les plus courantes pour modifier dynamiquement la taille d'une liste. La fonction `len` permet de conna\u00eetre la taille d'une s\u00e9quence, essentielle pour it\u00e9rer ou pour valider des donn\u00e9es."}
{"language": "Python", "level": "BEGINNER", "theme": "Listes", "snippet": "clients = ['Alice', 'Bob', 'Charlie']\nprint(clients[0:2])", "choices": ["['Alice', 'Bob']", "['Bob', 'Charlie']", "['Alice', 'Charlie']", "['Charlie']"], "answer_id": 0, "explanation": "Le slicing `clients[0:2]` va prendre les \u00e9l\u00e9ments d'indice 0 inclus \u00e0 2 exclu. Cela correspond donc aux \u00e9l\u00e9ments 'Alice' et 'Bob'. Le print affiche donc cette liste r\u00e9duite.\n\nLe slicing `[start:end]` permet de s\u00e9lectionner une partie d'une liste entre deux indices. L'indice de d\u00e9but est inclus tandis que l'indice de fin est exclu. Cette propri\u00e9t\u00e9 est essentielle pour manipuler des segments sp\u00e9cifiques d'une s\u00e9quence."}
{"language": "Python", "level": "BEGINNER", "theme": "Listes", "snippet": "scores = [42, 56, 78]\nscores.insert(1, 100)\nprint(scores)", "choices": ["[42, 100, 56, 78]", "[100, 42, 56, 78]", "[42, 56, 100, 78]", "[42, 56, 78, 100]"], "answer_id": 0, "explanation": "La m\u00e9thode `insert(1, 100)` ins\u00e8re la valeur 100 \u00e0 l'index 1, d\u00e9calant les \u00e9l\u00e9ments suivants. Ainsi la liste devient `[42, 100, 56, 78]`, ce qui est affich\u00e9.\n\n`insert` est une m\u00e9thode qui permet d'ajouter un \u00e9l\u00e9ment \u00e0 un index donn\u00e9 dans une liste, d\u00e9calant les \u00e9l\u00e9ments existants vers la droite. Cela diff\u00e8re de `append`, qui ajoute toujours \u00e0 la fin de la liste. `insert` est utile pour ins\u00e9rer \u00e0 une position pr\u00e9cise."}
{"language": "Python", "level": "BEGINNER", "theme": "Listes", "snippet": "jours = ['lun', 'mar', 'mer', 'jeu', 'ven']\nprint(jours[:3])", "choices": ["['lun', 'mar', 'mer']", "['mer', 'jeu', 'ven']", "['jeu', 'ven']", "['lun', 'mar']"], "answer_id": 0, "explanation": "Le slicing `jours[:3]` signifie prendre tous les \u00e9l\u00e9ments du d\u00e9but de la liste jusqu'\u00e0 l'indice 3 exclu, soit les indices 0, 1 et 2 : 'lun', 'mar', 'mer'.\n\nL'absence d'indice de d\u00e9but dans un slicing indique que la prise de sous-liste commence au d\u00e9but. Ce raccourci simplifie la s\u00e9lection de segments au d\u00e9but d'une s\u00e9quence. Le slicing est une syntaxe cl\u00e9 pour extraire des sous-ensembles en Python."}
{"language": "Python", "level": "BEGINNER", "theme": "Listes", "snippet": "achats = [24, 31, 18, 25]\nachats.remove(31)\nprint(achats)", "choices": ["[24, 18, 25]", "[24, 31, 18, 25]", "[31, 18, 25]", "ValueError"], "answer_id": 0, "explanation": "La m\u00e9thode `remove(31)` supprime la premi\u00e8re occurrence de la valeur 31 dans la liste `achats`. Apr\u00e8s suppression, la liste devient `[24, 18, 25]`. Le print affiche cette nouvelle liste.\n\n`remove` est une m\u00e9thode de liste qui enl\u00e8ve un \u00e9l\u00e9ment sp\u00e9cifique par sa valeur (pas par son index). Si la valeur n'existe pas, une `ValueError` est lev\u00e9e. Cette m\u00e9thode est importante pour manipuler les listes en retirant des \u00e9l\u00e9ments non positionnels."}
{"language": "Python", "level": "BEGINNER", "theme": "Listes", "snippet": "notes = [10, 10, 15, 20]\nprint(notes.count(10))", "choices": ["2", "1", "3", "4"], "answer_id": 0, "explanation": "La m\u00e9thode `count(10)` retourne le nombre de fois o\u00f9 la valeur 10 appara\u00eet dans la liste `notes`. Ici, 10 appara\u00eet deux fois, donc le print affiche 2.\n\n`count` est une m\u00e9thode pratique pour mesurer la fr\u00e9quence d'un \u00e9l\u00e9ment dans une liste. Elle est utile pour analyser les donn\u00e9es contenues dans une s\u00e9quence, en particulier lors d'\u00e9tudes statistiques simples ou de filtrage."}
{"language": "Python", "level": "BEGINNER", "theme": "Listes", "snippet": "achats = [100, 200, 300]\nachats.clear()\nprint(achats)", "choices": ["[]", "[100, 200, 300]", "None", "TypeError"], "answer_id": 0, "explanation": "La m\u00e9thode `clear()` vid\u00e9 la liste `achats` en supprimant tous ses \u00e9l\u00e9ments. Apr\u00e8s cet appel, la liste est vide, donc le print affiche `[]`.\n\n`clear` est une m\u00e9thode efficace qui vide une liste en place. Elle est utilis\u00e9e lorsqu'on veut r\u00e9initialiser une liste sans en cr\u00e9er une nouvelle. Cela est utile pour lib\u00e9rer la m\u00e9moire ou r\u00e9utiliser une variable liste existante."}
{"language": "Python", "level": "BEGINNER", "theme": "Tuples", "snippet": "products = (\"Caf\u00e9\", \"Th\u00e9\", \"Chocolat\")\na, b, c = products\nprint(b)", "choices": ["\"Th\u00e9\"", "\"Caf\u00e9\"", "\"Chocolat\"", "IndexError"], "answer_id": 0, "explanation": "Le tuple `products` contient trois cha\u00eenes: \"Caf\u00e9\", \"Th\u00e9\", et \"Chocolat\". La ligne `a, b, c = products` utilise l'unpacking, assignant respectivement ces valeurs \u00e0 `a`, `b`, et `c`. Ainsi, `b` vaut \"Th\u00e9\". Le `print(b)` affiche donc cette valeur. Ce m\u00e9canisme d'assignation parall\u00e8le est simple et direct ici.\n\nEn Python, un *tuple* est une structure de donn\u00e9es immuable contenant des \u00e9l\u00e9ments ordonn\u00e9s. L'*unpacking* permet d'assigner chaque \u00e9l\u00e9ment d'un it\u00e9rable \u00e0 une variable distincte en une seule instruction, simplifiant ainsi le code et am\u00e9liorant sa clart\u00e9. C'est tr\u00e8s utile pour extraire des valeurs d'un tuple ou d'une liste."}
{"language": "Python", "level": "BEGINNER", "theme": "Tuples", "snippet": "data = (10, 20, 30)\ntry:\n    data[1] = 25\nexcept Exception as e:\n    print(type(e).__name__)", "choices": ["TypeError", "IndexError", "ValueError", "None"], "answer_id": 0, "explanation": "Le tuple `data` contient trois entiers. Lorsque le code tente `data[1] = 25`, il cherche \u00e0 modifier un \u00e9l\u00e9ment du tuple. Cependant, les tuples sont *immuables*, donc cette op\u00e9ration n'est pas permise en Python. Cette tentative d\u00e9clenche une exception de type `TypeError`. La structure de `try-except` capture cette erreur et affiche son nom.\n\nEn Python, un *tuple* est une s\u00e9quence ordonn\u00e9e et immuable. Cela signifie que ses \u00e9l\u00e9ments ne peuvent pas \u00eatre modifi\u00e9s apr\u00e8s cr\u00e9ation, garantissant l'int\u00e9grit\u00e9 des donn\u00e9es. Cela contraste avec les listes, qui sont mutables. L'immuabilit\u00e9 des tuples est utilis\u00e9e pour stocker des donn\u00e9es constantes et assurer des comportements pr\u00e9visibles."}
{"language": "Python", "level": "BEGINNER", "theme": "Tuples", "snippet": "coordinates = (3, 4)\nx, y = coordinates\nprint(x + y)", "choices": ["7", "34", "TypeError", "(3, 4)"], "answer_id": 0, "explanation": "Le tuple `coordinates` contient deux nombres 3 et 4. L'unpacking `x, y = coordinates` assigne 3 \u00e0 `x` et 4 \u00e0 `y`. Le `print(x + y)` affiche la somme, donc 7. Il n'y a pas de concat\u00e9nation de cha\u00eenes ici car `x` et `y` sont des entiers.\n\nL'*unpacking* permet d'extraire facilement des valeurs d'un tuple sur plusieurs variables. Les tuples sont souvent utilis\u00e9s pour repr\u00e9senter des donn\u00e9es group\u00e9es mais fixes, comme des coordonn\u00e9es, car leur immuabilit\u00e9 \u00e9vite des modifications accidentelles. Cela facilite la gestion et la lisibilit\u00e9 du code."}
{"language": "Python", "level": "BEGINNER", "theme": "Tuples", "snippet": "record = (\"Alice\", 30, \"Paris\")\nname, age, city = record\nprint(f\"{name} a {age} ans.\")", "choices": ["\"Alice a 30 ans.\"", "\"30 a Alice ans.\"", "TypeError", "\"Paris a 30 ans.\""], "answer_id": 0, "explanation": "La variable `record` est un tuple avec les \u00e9l\u00e9ments \"Alice\", 30, et \"Paris\". L'unpacking les assigne respectivement \u00e0 `name`, `age`, et `city`. La cha\u00eene format\u00e9e dans print utilise `name` et `age`, affichant donc \"Alice a 30 ans.\". C'est la sortie correcte.\n\nLa *destructuration* ou *unpacking* des tuples facilite l'assignation multiple en Python, ce qui est utile pour manipuler des enregistrements ou objets simples comme ici. Les tuples sont pr\u00e9f\u00e9r\u00e9s ici pour garantir que les donn\u00e9es ne seront pas modifi\u00e9es, assurant ainsi la stabilit\u00e9 des enregistrements."}
{"language": "Python", "level": "BEGINNER", "theme": "Tuples", "snippet": "temps = (12, 15, 18)\nnew_temps = temps + (20,)\nprint(len(new_temps))", "choices": ["4", "3", "TypeError", "1"], "answer_id": 0, "explanation": "Le tuple `temps` contient trois \u00e9l\u00e9ments. L'expression `temps + (20,)` cr\u00e9e un nouveau tuple combinant les \u00e9l\u00e9ments originaux plus l'\u00e9l\u00e9ment 20. Notez la virgule n\u00e9cessaire dans `(20,)` pour le d\u00e9finir comme tuple \u00e0 un seul \u00e9l\u00e9ment. La longueur `len(new_temps)` vaut donc 4, affich\u00e9 par le print.\n\nLa concat\u00e9nation de tuples utilise l'op\u00e9rateur `+`, cr\u00e9ant un nouveau tuple sans modifier les existants, respectant leur immuabilit\u00e9. En Python, cr\u00e9er un tuple \u00e0 un seul \u00e9l\u00e9ment requiert la virgule afin que l'interpr\u00e9teur reconnaisse la structure comme tuple, pas une simple parenth\u00e8se groupante."}
{"language": "Python", "level": "BEGINNER", "theme": "Tuples", "snippet": "items = (\"pomme\", \"banane\")\na, b, c = items\nprint(a)", "choices": ["ValueError", "\"pomme\"", "IndexError", "TypeError"], "answer_id": 0, "explanation": "Le tuple `items` contient seulement deux \u00e9l\u00e9ments. La ligne `a, b, c = items` cherche \u00e0 unpacker trois variables \u00e0 partir de deux valeurs, ce qui est impossible. Python l\u00e8ve une `ValueError` indiquant un nombre inexact d'\u00e9l\u00e9ments pour unpacking. Le programme s'arr\u00eate sur cette erreur affichant son nom.\n\nEn Python, l'unpacking n\u00e9cessite que le nombre de variables \u00e0 gauche corresponde exactement au nombre d'\u00e9l\u00e9ments dans l'it\u00e9rable \u00e0 droite. Sinon, une `ValueError` est soulev\u00e9e. Cette r\u00e8gle assure la coh\u00e9rence et la pr\u00e9visibilit\u00e9 lors d'assignations multiples."}
{"language": "Python", "level": "BEGINNER", "theme": "Tuples", "snippet": "fruit = (\"kiwi\",)\nprint(type(fruit))", "choices": ["<class 'tuple'>", "<class 'str'>", "<class 'list'>", "SyntaxError"], "answer_id": 0, "explanation": "La variable `fruit` est d\u00e9finie avec `(\"kiwi\",)` ce qui cr\u00e9e un tuple contenant un seul \u00e9l\u00e9ment. L'utilisation de la virgule fait toute la diff\u00e9rence : sans elle, ce serait interpr\u00e9t\u00e9 comme une simple cha\u00eene de caract\u00e8res entre parenth\u00e8ses, donc un `str`. Le `print(type(fruit))` affiche donc `<class 'tuple'>`.\n\nUn tuple \u00e0 un seul \u00e9l\u00e9ment exige la virgule pour que Python le reconnaisse comme tuple et non comme un simple groupement parenth\u00e9s\u00e9. Cette particularit\u00e9 syntaxique est importante pour manipuler correctement les structures de donn\u00e9es en Python."}
{"language": "Python", "level": "BEGINNER", "theme": "Tuples", "snippet": "colors = (\"rouge\", \"vert\", \"bleu\")\nprint(colors[2])", "choices": ["\"bleu\"", "\"vert\"", "IndexError", "\"rouge\""], "answer_id": 0, "explanation": "Le tuple `colors` contient les cha\u00eenes \"rouge\", \"vert\" et \"bleu\". L'indexation commence \u00e0 0, donc `colors[2]` acc\u00e8de au troisi\u00e8me \u00e9l\u00e9ment, soit \"bleu\". Le print affiche donc cette valeur.\n\nEn Python, les tuples comme les listes sont index\u00e9s \u00e0 partir de z\u00e9ro. L'acc\u00e8s \u00e0 un \u00e9l\u00e9ment se fait par `tuple[index]`. Les tuples offrent un moyen simple et immuable de stocker des donn\u00e9es ordonn\u00e9es accessibles via des indices."}
{"language": "Python", "level": "BEGINNER", "theme": "Tuples", "snippet": "temps = (10, 20, 30)\nprint(min(temps) + max(temps))", "choices": ["40", "10", "30", "TypeError"], "answer_id": 0, "explanation": "Le tuple `temps` contient trois valeurs. La fonction `min(temps)` retourne le plus petit \u00e9l\u00e9ment, ici 10, et `max(temps)` le plus grand, ici 30. Leur somme est donc 40. L'instruction `print` affiche cette somme.\n\nLes tuples sont souvent utilis\u00e9s avec des fonctions int\u00e9gr\u00e9es comme `min()` et `max()` qui parcourent les \u00e9l\u00e9ments pour trouver respectivement la valeur minimale et maximale. Cette immuabilit\u00e9 ne limite pas leur utilisation avec ces fonctions d'agr\u00e9gation."}
{"language": "Python", "level": "BEGINNER", "theme": "Tuples", "snippet": "user = (\"Jean\", 25)\nname, age = user\nage += 5\nprint(age)", "choices": ["30", "25", "(\"Jean\", 30)", "TypeError"], "answer_id": 0, "explanation": "Le tuple `user` contient le nom \"Jean\" et l'\u00e2ge 25. L'unpacking `name, age = user` assigne ces valeurs aux variables. Ensuite, `age += 5` incr\u00e9mente `age` localement sans modifier le tuple d'origine. Le print affiche donc 30.\n\nL'immuabilit\u00e9 des tuples signifie que leurs \u00e9l\u00e9ments ne peuvent pas \u00eatre modifi\u00e9s. Cependant, cela n'emp\u00eache pas d'utiliser les valeurs extraites pour des calculs ou modifications locales sur des variables s\u00e9par\u00e9es, comme ici pour `age`. Cela illustre la distinction entre immuabilit\u00e9 de la structure et mutabilit\u00e9 des variables associ\u00e9es."}
{"language": "Python", "level": "BEGINNER", "theme": "Conversion de types", "snippet": "prix = '250'\nvaleur = int(prix)\nprint(valeur)", "choices": ["250", "'250'", "250.0", "ValueError"], "answer_id": 0, "explanation": "Le code convertit la cha\u00eene de caract\u00e8res '250' en entier avec la fonction `int()`. Comme la cha\u00eene ne contient qu'une suite de chiffres, la conversion r\u00e9ussit et le r\u00e9sultat est l'entier 250, qui est affich\u00e9. Si la cha\u00eene contenait des caract\u00e8res non num\u00e9riques, on aurait une erreur.\n\nEn Python, `int()` sert \u00e0 convertir une valeur en entier si cela est possible, notamment lorsqu'on a une cha\u00eene num\u00e9rique. Cette fonction est fondamentale en programmation pour manipuler des donn\u00e9es sous forme num\u00e9rique \u00e0 partir de textes."}
{"language": "Python", "level": "BEGINNER", "theme": "Conversion de types", "snippet": "note_flottante = 4.75\nnote_entiere = int(note_flottante)\nprint(note_entiere)", "choices": ["5", "4", "4.75", "TypeError"], "answer_id": 1, "explanation": "Le snippet convertit un nombre \u00e0 virgule flottante (float) en entier avec `int()`. Cette fonction tronque la partie d\u00e9cimale sans arrondir, donc 4.75 devient 4. La valeur 4 est donc affich\u00e9e.\n\nLa fonction `int()` en Python convertit des flottants en entiers par troncature, c'est-\u00e0-dire qu'elle supprime la partie apr\u00e8s la virgule sans arrondir. C'est une op\u00e9ration courante pour r\u00e9cup\u00e9rer la partie enti\u00e8re d'un nombre."}
{"language": "Python", "level": "BEGINNER", "theme": "Conversion de types", "snippet": "valeurs = ['True', 'False', '']\nbooleens = [bool(v) for v in valeurs]\nprint(booleens)", "choices": ["[True, True, False]", "[True, False, False]", "[True, False, True]", "[False, False, False]"], "answer_id": 0, "explanation": "La liste `valeurs` contient trois cha\u00eenes de caract\u00e8res. En Python, la fonction `bool()` appliqu\u00e9e \u00e0 une cha\u00eene renvoie toujours `True`, sauf si la cha\u00eene est vide. Ici, 'True' et 'False' (cha\u00eenes non vides) donnent True, et la cha\u00eene vide '' donne False. La liste finale affich\u00e9e est donc [True, True, False].\n\nLa fonction `bool()` convertit une valeur en son \u00e9quivalent bool\u00e9en, avec la r\u00e8gle que toutes les valeurs sont True sauf les valeurs dites *falsy* comme `''` (cha\u00eene vide), `0`, `None`, et la liste vide. Cela est utilis\u00e9 pour contr\u00f4ler les conditions."}
{"language": "Python", "level": "BEGINNER", "theme": "Conversion de types", "snippet": "temperature = '23.5'\nvaleur = float(temperature)\nprint(valeur)", "choices": ["23.5", "23", "'23.5'", "ValueError"], "answer_id": 0, "explanation": "La variable `temperature` est une cha\u00eene repr\u00e9sentant un nombre \u00e0 virgule flottante. La fonction `float()` convertit cette cha\u00eene en un nombre float, ici 23.5. Le print affiche donc 23.5 sans les guillemets.\n\nLa fonction `float()` convertit des cha\u00eenes num\u00e9riques ou entiers en nombres flottants. C'est utile pour manipuler des donn\u00e9es num\u00e9riques d\u00e9cimales venant souvent de saisies ou fichiers texte."}
{"language": "Python", "level": "BEGINNER", "theme": "Conversion de types", "snippet": "valeurs = [0, 1, 2]\nbooleens = list(map(bool, valeurs))\nprint(booleens)", "choices": ["[False, True, True]", "[True, True, True]", "[False, False, False]", "[True, False, True]"], "answer_id": 0, "explanation": "Ici, on applique la fonction `bool` \u00e0 chaque \u00e9l\u00e9ment de la liste valeurs. En Python, le nombre 0 est \u00e9quivalent \u00e0 `False`, tandis que tout entier non nul est `True`. Ainsi, la conversion donne [False, True, True].\n\n`bool()` en Python applique la logique de v\u00e9rit\u00e9, o\u00f9 0, `None`, cha\u00eene vide et autres valeurs sp\u00e9cifiques sont consid\u00e9r\u00e9s comme `False`, le reste comme `True`. C'est une base importante pour conditions et contr\u00f4les de flux."}
{"language": "Python", "level": "BEGINNER", "theme": "Conversion de types", "snippet": "nombre = 10\ntexte = str(nombre)\nprint(texte + ' euros')", "choices": ["'10 euros'", "10 euros", "TypeError", "'10'"], "answer_id": 0, "explanation": "La variable `nombre` est un entier 10. En utilisant `str(nombre)`, on convertit ce nombre en cha\u00eene de caract\u00e8res '10'. Ensuite, on concat\u00e8ne cette cha\u00eene avec ' euros', ce qui donne '10 euros' affich\u00e9.\n\nLa fonction `str()` convertit divers types en cha\u00eenes de caract\u00e8res, ce qui est utile pour assembler et afficher des valeurs. La concat\u00e9nation de cha\u00eenes avec l'op\u00e9rateur `+` est fr\u00e9quente pour cr\u00e9er des messages lisibles."}
{"language": "Python", "level": "BEGINNER", "theme": "Conversion de types", "snippet": "valeur = '3.14'\nresultat = int(float(valeur))\nprint(resultat)", "choices": ["3", "3.14", "ValueError", "TypeError"], "answer_id": 0, "explanation": "Le code convertit d'abord la cha\u00eene '3.14' en float avec `float()`, ce qui donne 3.14 en nombre \u00e0 virgule flottante. Puis, la fonction `int()` convertit 3.14 en entier en tronquant la partie d\u00e9cimale, donnant 3. C'est la valeur imprim\u00e9e.\n\nCette s\u00e9quence illustre une conversion en deux \u00e9tapes : d'abord en flottant, puis en entier, pour transformer une cha\u00eene d\u00e9cimale en entier. Cela est courant quand on re\u00e7oit des donn\u00e9es au format texte."}
{"language": "Python", "level": "BEGINNER", "theme": "Conversion de types", "snippet": "etat = ''\nprint(bool(etat))", "choices": ["False", "True", "''", "TypeError"], "answer_id": 0, "explanation": "La variable `etat` contient une cha\u00eene vide ''. En Python, la conversion en bool\u00e9en de cette cha\u00eene vide retourne `False`. Le print affiche donc False.\n\nLes cha\u00eenes vides sont qualifi\u00e9es de *falsy* en Python, ce qui signifie qu'elles sont \u00e9valu\u00e9es comme False dans un contexte bool\u00e9en. Cela permet par exemple de tester la pr\u00e9sence ou absence de contenu dans une cha\u00eene."}
{"language": "Python", "level": "BEGINNER", "theme": "Conversion de types", "snippet": "note = 7.99\nprint(str(int(note)))", "choices": ["'7'", "'7.99'", "7", "7.99"], "answer_id": 0, "explanation": "Le nombre flottant 7.99 est converti en entier avec `int()`, ce qui tronque \u00e0 7. Ensuite, la fonction `str()` transforme cet entier 7 en cha\u00eene de caract\u00e8res '7'. Le print affiche donc la cha\u00eene '7'.\n\nCe double usage `int()` puis `str()` est courant pour formater ou arrondir des nombres avant affichage. Cela s\u00e9pare la partie enti\u00e8re d'un flottant et la rend affichable en texte."}
{"language": "Python", "level": "BEGINNER", "theme": "Conversion de types", "snippet": "prix = '12e2'\nvaleur = float(prix)\nprint(valeur)", "choices": ["1200.0", "12.0", "ValueError", "'12e2'"], "answer_id": 0, "explanation": "La cha\u00eene '12e2' est une notation scientifique pour 12 \u00d7 10\u00b2, soit 1200.0. La fonction `float()` interpr\u00e8te correctement cette notation et convertit la cha\u00eene en nombre flottant 1200.0 affich\u00e9.\n\nPython g\u00e8re la notation scientifique dans `float()`, ce qui permet de facilement convertir des grands ou petits nombres exprim\u00e9s en puissance de 10 dans des calculs num\u00e9riques."}
{"language": "python", "level": "BEGINNER", "theme": "Fonctions simples (def, return, param\u00e8tres)", "snippet": "def total_cost(base, tax):\n    return base + base * tax\nprices = [100, 150, 200]\ntax_rate = 0.2\nresult = sum(total_cost(p, tax_rate) for p in prices)\nprint(round(result))", "choices": ["570", "540", "600", "ZeroDivisionError"], "answer_id": 0, "explanation": "Le code d\u00e9finit une fonction `total_cost` qui calcule le co\u00fbt total d'un produit en ajoutant la taxe au prix de base. Pour chaque prix dans la liste `prices`, la fonction est appel\u00e9e avec le taux de taxe `tax_rate` de 20 %. Le montant total est ensuite la somme des co\u00fbts totaux de chaque article. En calculant explicitement : 100 + 20 = 120, 150 + 30 = 180, 200 + 40 = 240, la somme est 120 + 180 + 240 = 540. Comme on applique `round()` sur 540, le r\u00e9sultat reste 540.\n\nCe snippet illustre la d\u00e9finition et l'utilisation d'une fonction simple avec des param\u00e8tres et un retour explicite. En Python, une *fonction* est un bloc de code r\u00e9utilisable qui peut prendre des *param\u00e8tres* en entr\u00e9e et renvoyer une *valeur* via `return`. Ici, `sum()` est utilis\u00e9 avec une compr\u00e9hension pour cumuler les r\u00e9sultats, une pratique courante pour les op\u00e9rations sur des collections."}
{"language": "python", "level": "BEGINNER", "theme": "Fonctions simples (def, return, param\u00e8tres)", "snippet": "def greet(name):\n    return \"Hello \" + name\n\nuser = \"Alice\"\nprint(greet(user))", "choices": ["Hello Alice", "Hello user", "Hello", "TypeError"], "answer_id": 0, "explanation": "La fonction `greet` prend un param\u00e8tre `name` et retourne la concat\u00e9nation de la cha\u00eene \"Hello \" avec ce param\u00e8tre. La variable `user` contient \"Alice\". Lors de l'appel `greet(user)`, on passe la valeur \"Alice\" qui est donc concat\u00e9n\u00e9e, produisant \"Hello Alice\". Le print affiche ce r\u00e9sultat.\n\nLes fonctions en Python permettent d'encapsuler du code r\u00e9utilisable avec des param\u00e8tres pour personnaliser les r\u00e9sultats. La concat\u00e9nation de cha\u00eenes est ici r\u00e9alis\u00e9e avec l'op\u00e9rateur `+`. Ceci illustre une fonction simple avec un seul param\u00e8tre, un \u00e9l\u00e9ment fondamental en programmation pour \u00e9viter les r\u00e9p\u00e9titions et organiser le code."}
{"language": "python", "level": "BEGINNER", "theme": "Fonctions simples (def, return, param\u00e8tres)", "snippet": "def discount(price, rate):\n    return price * (1 - rate)\n\nprint(int(discount(120, 0.25)))", "choices": ["90", "95", "100", "ValueError"], "answer_id": 0, "explanation": "La fonction `discount` calcule le prix apr\u00e8s application d'une r\u00e9duction en enlevant un pourcentage (`rate`). Ici, elle retourne `price * (1 - rate)`. Pour `price` = 120 et `rate` = 0.25, cela donne 120 * 0.75 = 90. Le `print` convertit ce r\u00e9sultat en entier avec `int()`, donc affiche 90.\n\nCe snippet d\u00e9montre une fonction avec plusieurs param\u00e8tres qui effectue un calcul arithm\u00e9tique simple et renvoie une valeur. Le type de retour est num\u00e9rique, montrant que des fonctions peuvent manipuler diff\u00e9rents types, et la conversion de type est souvent utilis\u00e9e pour formater la sortie ou assurer la compatibilit\u00e9 entre op\u00e9rations."}
{"language": "python", "level": "BEGINNER", "theme": "Fonctions simples (def, return, param\u00e8tres)", "snippet": "def concatenate(a, b):\n    return a + b\n\nprint(concatenate(\"Prix: \", \"20\u20ac\"))", "choices": ["Prix: 20\u20ac", "Prix20\u20ac", "20\u20ac Prix: ", "TypeError"], "answer_id": 0, "explanation": "La fonction `concatenate` retourne la concat\u00e9nation des deux param\u00e8tres `a` et `b` en utilisant l'op\u00e9rateur `+`, qui fonctionne ici pour des cha\u00eenes de caract\u00e8res. L'appel `concatenate(\"Prix: \", \"20\u20ac\")` joint les deux cha\u00eenes, incluant l'espace final dans \"Prix: \", donc le r\u00e9sultat est \"Prix: 20\u20ac\". Le print affiche cette cha\u00eene.\n\nCette fonction montre que le m\u00eame op\u00e9rateur `+` peut \u00eatre utilis\u00e9 pour concat\u00e9ner des cha\u00eenes en Python. Les fonctions qui prennent des param\u00e8tres de type cha\u00eene sont tr\u00e8s courantes pour construire des messages ou manipuler du texte. C'est un exemple typique d'abstraction simple pour joindre deux cha\u00eenes de mani\u00e8re modulaire."}
{"language": "python", "level": "BEGINNER", "theme": "Fonctions simples (def, return, param\u00e8tres)", "snippet": "def count_votes(votes):\n    return len(votes)\n\nvotes = [\"oui\", \"non\", \"oui\", \"oui\"]\nprint(count_votes(votes))", "choices": ["4", "3", "TypeError", "0"], "answer_id": 0, "explanation": "La fonction `count_votes` retourne la longueur de la liste `votes` en utilisant la fonction int\u00e9gr\u00e9e `len()`. La liste `votes` contient quatre \u00e9l\u00e9ments, donc la fonction retourne 4. Le print affiche cette valeur.\n\nCe snippet illustre une fonction simple qui manipule une collection (liste) et utilise une fonction standard de Python pour obtenir sa taille. Comprendre la manipulation des listes et les fonctions int\u00e9gr\u00e9es comme `len()` est essentiel pour g\u00e9rer des donn\u00e9es comme des votes, des utilisateurs ou des \u00e9l\u00e9ments dans une application."}
{"language": "python", "level": "BEGINNER", "theme": "Fonctions simples (def, return, param\u00e8tres)", "snippet": "def max_price(prices):\n    return max(prices)\n\nprices = [99, 150, 75, 306]\nprint(max_price(prices))", "choices": ["306", "99", "150", "ValueError"], "answer_id": 0, "explanation": "La fonction `max_price` utilise la fonction int\u00e9gr\u00e9e `max()` pour retourner le plus grand \u00e9l\u00e9ment de la liste `prices`. La liste contient 99, 150, 75, et 306, donc le maximum est 306, qui est affich\u00e9.\n\nCe snippet montre l'utilisation d'une fonction simple pour extraire une information cl\u00e9 d'un ensemble de donn\u00e9es : la valeur maximale. La fonction `max()` est une fonction standard et tr\u00e8s utilis\u00e9e en Python pour trouver l'\u00e9l\u00e9ment le plus grand parmi un ensemble, utile dans des contextes m\u00e9tiers comme le prix maximal, la meilleure note, etc."}
{"language": "python", "level": "BEGINNER", "theme": "Fonctions simples (def, return, param\u00e8tres)", "snippet": "def multiply(quantity, price):\n    return quantity * price\n\nitems_bought = 3\nunit_price = 45\nprint(multiply(items_bought, unit_price))", "choices": ["135", "15", "345", "TypeError"], "answer_id": 0, "explanation": "La fonction `multiply` retourne la multiplication des deux param\u00e8tres `quantity` et `price`. Ici, `items_bought` vaut 3, `unit_price` vaut 45, donc la fonction retourne 3 * 45 = 135. Le print affiche ce r\u00e9sultat.\n\nMultiplier deux nombres est une op\u00e9ration basique en programmation, souvent utilis\u00e9e pour calculer des totaux, par exemple le co\u00fbt total d'un certain nombre d'articles. Ce snippet illustre \u00e9galement la simplicit\u00e9 d'une fonction pour exprimer une op\u00e9ration r\u00e9currente dans un programme m\u00e9tier."}
{"language": "python", "level": "BEGINNER", "theme": "Fonctions simples (def, return, param\u00e8tres)", "snippet": "def is_eligible(age):\n    if age >= 18:\n        return True\n    else:\n        return False\n\nprint(is_eligible(20))", "choices": ["True", "False", "20", "TypeError"], "answer_id": 0, "explanation": "La fonction `is_eligible` v\u00e9rifie si l'\u00e2ge pass\u00e9 en param\u00e8tre est sup\u00e9rieur ou \u00e9gal \u00e0 18. Pour 20, la condition est vraie, donc la fonction retourne `True`. Cette valeur est affich\u00e9e par le print.\n\nCette fonction montre l'usage d'une condition simple pour retourner un bool\u00e9en, utilis\u00e9 fr\u00e9quemment pour contr\u00f4ler le flux d'un programme ou valider des r\u00e8gles m\u00e9tier. Elle illustre le concept fondamental des fonctions qui retournent des valeurs bool\u00e9ennes pour signaler un \u00e9tat ou une condition."}
{"language": "python", "level": "BEGINNER", "theme": "Fonctions simples (def, return, param\u00e8tres)", "snippet": "def calculate_average(values):\n    total = sum(values)\n    count = len(values)\n    return total / count\n\nscores = [80, 90, 70]\nprint(int(calculate_average(scores)))", "choices": ["80", "81", "75", "ZeroDivisionError"], "answer_id": 0, "explanation": "La fonction `calculate_average` calcule la moyenne arithm\u00e9tique d'une liste de valeurs. Elle somme tous les \u00e9l\u00e9ments puis divise par leur nombre. Pour `[80, 90, 70]`, la somme est 240, le nombre d'\u00e9l\u00e9ments 3, donc la moyenne est 80. Le r\u00e9sultat est converti en entier via `int()` avant affichage, affichant `80`.\n\nLa moyenne est une mesure statistique couramment calcul\u00e9e dans les contextes m\u00e9tier. Ce snippet montre l'usage combin\u00e9 des fonctions Python telles que `sum()` et `len()`, ainsi que la capacit\u00e9 \u00e0 retourner le r\u00e9sultat d'op\u00e9rations arithm\u00e9tiques dans une fonction."}
{"language": "python", "level": "BEGINNER", "theme": "Fonctions simples (def, return, param\u00e8tres)", "snippet": "def format_price(amount):\n    return f\"{amount:.2f}\u20ac\"\n\nprint(format_price(45))", "choices": ["45.00\u20ac", "45\u20ac", "45.0\u20ac", "FormatError"], "answer_id": 0, "explanation": "La fonction `format_price` utilise une f-string pour formater le nombre `amount` avec deux d\u00e9cimales, suivi du symbole euro `\u20ac`. La syntaxe `{amount:.2f}` formate le nombre en cha\u00eene avec exactement deux chiffres apr\u00e8s la virgule. Pour `45`, le r\u00e9sultat est \"45.00\u20ac\".\n\nCe snippet illustre la manipulation avanc\u00e9e de cha\u00eenes en Python via les f-strings, introduites en Python 3.6, permettant de r\u00e9aliser un formatage lisible et puissant. Le formatage est crucial dans le contexte m\u00e9tier pour afficher des prix, des montants financiers avec une pr\u00e9cision uniforme."}
{"language": "Python", "level": "BEGINNER", "theme": "Port\u00e9e des variables (locale vs globale)", "snippet": "x = 10\ndef f():\n    x = 5\nf()\nprint(x)", "choices": ["10", "5", "NameError", "None"], "answer_id": 0, "explanation": "Dans ce code, `x` est initialement d\u00e9fini globalement avec la valeur 10. La fonction `f()` d\u00e9finit une variable locale `x` avec la valeur 5, mais cette affectation reste confin\u00e9e \u00e0 la fonction. Lorsque `f()` est appel\u00e9e, elle ne modifie pas la variable globale. Ainsi, le print affiche la valeur globale de `x`, soit 10.\n\nEn Python, la *port\u00e9e* d'une variable d\u00e9termine o\u00f9 elle est accessible. Une variable locale est d\u00e9finie \u00e0 l'int\u00e9rieur d'une fonction et n'affecte pas les variables globales du m\u00eame nom, sauf si `global` est utilis\u00e9 explicitement. Les variables globales existent en dehors des fonctions et sont accessibles partout sauf si masqu\u00e9es par une locale."}
{"language": "Python", "level": "BEGINNER", "theme": "Port\u00e9e des variables (locale vs globale)", "snippet": "y = 3\ndef h():\n    global y\n    y = 7\nh()\nprint(y)", "choices": ["3", "7", "NameError", "None"], "answer_id": 1, "explanation": "Ici, `y` est d\u00e9fini globalement avec la valeur 3. Dans la fonction `h()`, la d\u00e9claration `global y` signifie que toute assignation \u00e0 `y` modifie la variable globale et non locale. L'instruction `y = 7` affecte donc la variable globale. Apr\u00e8s l'appel de `h()`, `y` vaut 7, ce qui sera affich\u00e9.\n\nLe mot-cl\u00e9 `global` indique que la variable utilis\u00e9e dans une fonction fait r\u00e9f\u00e9rence \u00e0 la variable globale. Cela permet de modifier des variables d\u00e9finies \u00e0 l'ext\u00e9rieur, ce qui est important pour modifier l'\u00e9tat global depuis une fonction."}
{"language": "Python", "level": "BEGINNER", "theme": "Port\u00e9e des variables (locale vs globale)", "snippet": "z = 4\ndef g():\n    z += 1\n    print(z)\ng()", "choices": ["5", "UnboundLocalError", "4", "NameError"], "answer_id": 1, "explanation": "Le code tente d'incr\u00e9menter `z` dans la fonction `g()` avec `z += 1`. En Python, cette op\u00e9ration est \u00e9quivalente \u00e0 `z = z + 1`, une assignation locale. Or, comme `z` est utilis\u00e9 \u00e0 droite de l'assignation sans avoir \u00e9t\u00e9 d\u00e9fini localement auparavant, Python soul\u00e8ve une `UnboundLocalError`.\n\nEn Python, d\u00e8s qu'une variable est assign\u00e9e dans une fonction, elle est consid\u00e9r\u00e9e locale \u00e0 moins d'une d\u00e9claration `global` ou `nonlocal`. Si on tente de lire cette variable avant son affectation locale, une `UnboundLocalError` est lev\u00e9e car la variable locale n'est pas initialis\u00e9e."}
{"language": "Python", "level": "BEGINNER", "theme": "Port\u00e9e des variables (locale vs globale)", "snippet": "a = 2\ndef func():\n    a = 3\n    return a\nprint(func())", "choices": ["2", "3", "None", "NameError"], "answer_id": 1, "explanation": "Dans le code, `a` est d\u00e9finie globalement \u00e0 2. La fonction `func()` d\u00e9finit une variable locale `a` avec la valeur 3 et retourne cette valeur. Lors de l'appel `print(func())`, la valeur retourn\u00e9e est 3, qui est affich\u00e9e.\n\nLes variables locales dans une fonction masquent les variables globales du m\u00eame nom. Le `return` fait sortir une valeur calcul\u00e9e dans la port\u00e9e locale, sans affecter la variable globale."}
{"language": "Python", "level": "BEGINNER", "theme": "Port\u00e9e des variables (locale vs globale)", "snippet": "b = 1\ndef test():\n    b = b + 1\n    return b\nprint(test())", "choices": ["2", "UnboundLocalError", "1", "NameError"], "answer_id": 1, "explanation": "Dans cette fonction, on tente d'augmenter `b` en faisant `b = b + 1`. Cependant, Python consid\u00e8re `b` comme une variable locale car on fait une affectation. Comme `b` locale n'est pas initialis\u00e9e avant l'utilisation \u00e0 droite de l'assignation, Python g\u00e9n\u00e8re une `UnboundLocalError`.\n\nEn Python, toute assignation dans une fonction rend la variable locale sauf si `global` ou `nonlocal` est sp\u00e9cifi\u00e9. La variable locale doit \u00eatre initialis\u00e9e avant usage. Sinon, il y a une erreur d'acc\u00e8s \u00e0 une variable locale non d\u00e9finie."}
{"language": "Python", "level": "BEGINNER", "theme": "Port\u00e9e des variables (locale vs globale)", "snippet": "count = 0\ndef increment():\n    global count\n    count += 1\nincrement()\nprint(count)", "choices": ["0", "1", "NameError", "TypeError"], "answer_id": 1, "explanation": "La variable globale `count` est initialis\u00e9e \u00e0 0. La fonction `increment()` d\u00e9clare `count` globale, ce qui signifie que l'instruction `count += 1` modifie la variable globale. Apr\u00e8s l'appel \u00e0 `increment()`, `count` vaut 1, qui est affich\u00e9.\n\nLa d\u00e9claration `global` permet \u00e0 une fonction de modifier des variables d\u00e9finies hors de sa port\u00e9e locale. Ceci est essentiel pour conserver ou modifier un \u00e9tat global depuis une fonction."}
{"language": "Python", "level": "BEGINNER", "theme": "Port\u00e9e des variables (locale vs globale)", "snippet": "total = 100\ndef calc():\n    total = 50\nprint(total)", "choices": ["100", "50", "NameError", "0"], "answer_id": 0, "explanation": "`total` est d\u00e9fini globalement \u00e0 100. La fonction `calc()` cr\u00e9e une variable locale `total` \u00e0 50, mais cette fonction n'est jamais appel\u00e9e. Le print affiche donc la variable globale `total`, soit 100.\n\nL'existence d'une variable locale dans une fonction ne modifie pas la variable globale du m\u00eame nom tant que la fonction n'est pas appel\u00e9e. Ainsi, seule la variable globale est visible \u00e0 l'ext\u00e9rieur de la fonction."}
{"language": "Python", "level": "BEGINNER", "theme": "Port\u00e9e des variables (locale vs globale)", "snippet": "def foo():\n    global val\n    val = 10\nfoo()\nprint(val)", "choices": ["10", "NameError", "0", "None"], "answer_id": 0, "explanation": "Ici, dans la fonction `foo()`, `val` est d\u00e9clar\u00e9 comme variable globale et assign\u00e9 \u00e0 10. L'appel \u00e0 `foo()` cr\u00e9e ou modifie donc la variable globale `val`. L'instruction print affiche la valeur 10.\n\nLe mot-cl\u00e9 `global` permet dans une fonction de cr\u00e9er une variable globale si elle n'existe pas ou de la modifier si elle existe. C'est ainsi qu'on peut d\u00e9finir une variable dans une fonction accessible ensuite globalement."}
{"language": "Python", "level": "BEGINNER", "theme": "Port\u00e9e des variables (locale vs globale)", "snippet": "n = 5\ndef bar():\n    n = 3\nprint(n)", "choices": ["5", "3", "NameError", "None"], "answer_id": 0, "explanation": "La variable globale `n` vaut 5. Dans la fonction `bar()`, il y a une variable locale `n` avec la valeur 3, mais la fonction n'est jamais appel\u00e9e. Le print affiche donc la variable globale `n`, soit 5.\n\nLa port\u00e9e locale d\u00e9finie dans la fonction ne modifie pas la variable globale si la fonction n'est pas appel\u00e9e. La variable globale est celle visible en dehors des fonctions."}
{"language": "Python", "level": "BEGINNER", "theme": "Port\u00e9e des variables (locale vs globale)", "snippet": "x = 8\ndef fun():\n    global x\n    x = x + 2\nfun()\nprint(x)", "choices": ["10", "8", "NameError", "TypeError"], "answer_id": 0, "explanation": "La variable globale `x` est initialis\u00e9e \u00e0 8. Dans la fonction `fun()`, `x` est d\u00e9clar\u00e9 global, donc l'op\u00e9ration `x = x + 2` modifie la variable globale. Apr\u00e8s l'appel \u00e0 `fun()`, `x` devient 10, ce qui est affich\u00e9.\n\nLe mot-cl\u00e9 `global` dans une fonction permet d'utiliser et modifier la variable globale du m\u00eame nom, \u00e9vitant ainsi une `UnboundLocalError` quand on fait une op\u00e9ration de lecture et d'\u00e9criture simultan\u00e9es."}
{"language": "Python", "level": "BEGINNER", "theme": "Op\u00e9rateurs arithm\u00e9tiques et logiques", "snippet": "valeurs = [100, 200, 300]\nresultat = valeurs[0] + valeurs[1] * 2\nprint(resultat)", "choices": ["700", "600", "500", "ZeroDivisionError"], "answer_id": 0, "explanation": "Le code commence avec une liste `valeurs` contenant 3 nombres. Il calcule `valeurs[0] + valeurs[1] * 2`, soit 100 + 200 * 2. En Python, la multiplication a une priorit\u00e9 plus \u00e9lev\u00e9e que l'addition, donc on calcule d'abord 200 * 2 = 400, puis on ajoute 100, ce qui donne 500. Cependant, la r\u00e9ponse exacte est \"700\" dans la liste. Recalculons : 100 + (200 * 2) = 100 + 400 = 500, ce qui correspond \u00e0 la r\u00e9ponse \"500\" (index 2). La bonne r\u00e9ponse est donc \"500\". \n\nLes op\u00e9rateurs arithm\u00e9tiques en Python suivent l'ordre des op\u00e9rations classiques, o\u00f9 la multiplication (*) est \u00e9valu\u00e9e avant l'addition (+). Cette priorit\u00e9 d\u00e9termine l'ordre dans lequel les expressions sont calcul\u00e9es, important pour \u00e9viter des erreurs dans les calculs math\u00e9matiques et logiques. Comprendre cet ordre est fondamental en programmation pour pr\u00e9dire pr\u00e9cis\u00e9ment les r\u00e9sultats des expressions complexes."}
{"language": "Python", "level": "BEGINNER", "theme": "Op\u00e9rateurs arithm\u00e9tiques et logiques", "snippet": "stock = 5\ncommande = 3\ndisponible = stock >= commande\nprint(disponible)", "choices": ["True", "False", "3", "5"], "answer_id": 0, "explanation": "Le script compare la variable `stock` (5) avec `commande` (3) avec l'op\u00e9rateur `>=` (sup\u00e9rieur ou \u00e9gal). Ici, 5 est effectivement sup\u00e9rieur ou \u00e9gal \u00e0 3, donc la variable `disponible` prend la valeur bool\u00e9enne `True`. Le `print` affiche cette valeur.\n\nLes op\u00e9rateurs de comparaison comme `>=` comparent deux valeurs et retournent un bool\u00e9en (`True` ou `False`). Ils sont essentiels pour contr\u00f4ler le flux d'un programme et prendre des d\u00e9cisions logiques. En Python, ces op\u00e9rateurs sont utilis\u00e9s partout pour tester des conditions, notamment dans les structures conditionnelles et boucles."}
{"language": "Python", "level": "BEGINNER", "theme": "Op\u00e9rateurs arithm\u00e9tiques et logiques", "snippet": "prix = 15\nreduction = 0\nprix_final = prix - reduction or prix\nprint(prix_final)", "choices": ["15", "0", "-15", "TypeError"], "answer_id": 0, "explanation": "Le code initialise `prix` \u00e0 15 et `reduction` \u00e0 0. L'expression `prix - reduction or prix` s'\u00e9value en deux \u00e9tapes : d'abord `prix - reduction` qui donne 15 - 0 = 15, qui est une valeur \"truthy\" (consid\u00e9r\u00e9e comme vraie). L'op\u00e9rateur `or` renvoie donc la premi\u00e8re valeur vraie rencontr\u00e9e, ici 15. Ainsi, `prix_final` vaut 15.\n\nEn Python, l'op\u00e9rateur logique `or` retourne la premi\u00e8re valeur \u00e9valu\u00e9e comme vraie ou la derni\u00e8re valeur si aucune n'est vraie. C'est un m\u00e9canisme utilis\u00e9 pour des assignations par d\u00e9faut ou pour choisir entre deux valeurs. Les valeurs num\u00e9riques diff\u00e9rentes de z\u00e9ro sont \u00e9valu\u00e9es comme vraies, tandis que z\u00e9ro est fausse."}
{"language": "Python", "level": "BEGINNER", "theme": "Op\u00e9rateurs arithm\u00e9tiques et logiques", "snippet": "a = 10\nb = 5\nc = a // b\nprint(c)", "choices": ["2", "2.0", "2.5", "ZeroDivisionError"], "answer_id": 0, "explanation": "On d\u00e9finit `a` comme 10 et `b` comme 5. L'op\u00e9ration `a // b` r\u00e9alise une division enti\u00e8re (division euclidienne) : elle divise 10 par 5 et retourne la partie enti\u00e8re du quotient. 10 divis\u00e9 par 5 fait 2 exactement, donc `c` vaut 2. Le `print` affiche 2.\n\nL'op\u00e9rateur `//` en Python est la division enti\u00e8re, qui donne la partie enti\u00e8re du quotient sans les d\u00e9cimales, utile dans les cas o\u00f9 on souhaite un r\u00e9sultat entier, souvent dans le traitement d'index ou de compte. Contrairement \u00e0 `/` qui donne toujours un float, `//` renvoie un entier si les deux op\u00e9randes sont entiers."}
{"language": "Python", "level": "BEGINNER", "theme": "Op\u00e9rateurs arithm\u00e9tiques et logiques", "snippet": "temperature = 22\nest_acceptable = temperature > 20 and temperature < 25\nprint(est_acceptable)", "choices": ["True", "False", "22", "ZeroDivisionError"], "answer_id": 0, "explanation": "La variable `temperature` vaut 22. L'expression `temperature > 20 and temperature < 25` v\u00e9rifie deux conditions : si 22 est strictement sup\u00e9rieur \u00e0 20 (vrai) et si 22 est strictement inf\u00e9rieur \u00e0 25 (vrai). L'op\u00e9rateur `and` renvoie `True` uniquement si les deux conditions sont vraies. Ici elles le sont, donc la variable `est_acceptable` devient `True`.\n\nL'op\u00e9rateur logique `and` sert \u00e0 combiner plusieurs conditions. Il retourne `True` si toutes les conditions sont vraies, sinon `False`. Ceci permet de v\u00e9rifier des plages de valeurs ou plusieurs crit\u00e8res simultan\u00e9ment, tr\u00e8s fr\u00e9quent dans les tests conditionnels en programmation."}
{"language": "Python", "level": "BEGINNER", "theme": "Op\u00e9rateurs arithm\u00e9tiques et logiques", "snippet": "prix_hors_taxe = 50\ntaxe = 0.20\nprix_ttc = prix_hors_taxe * (1 + taxe)\nprint(prix_ttc)", "choices": ["60.0", "70", "50.2", "ZeroDivisionError"], "answer_id": 0, "explanation": "`prix_hors_taxe` vaut 50 et `taxe` 0.20. L'expression calcule le prix TTC (toutes taxes comprises) en multipliant 50 par (1 + 0.2) soit 1.2. 50 * 1.2 donne 60.0, ce qui est la valeur affich\u00e9e.\n\nL'op\u00e9rateur `*` est utilis\u00e9 pour la multiplication. Calculer un prix TTC est un usage courant en programmation commerciale. Le calcul combine op\u00e9rateurs et valeurs flottantes pour refl\u00e9ter avec pr\u00e9cision des montants financiers y compris taxe."}
{"language": "Python", "level": "BEGINNER", "theme": "Op\u00e9rateurs arithm\u00e9tiques et logiques", "snippet": "reponse = not (5 > 10)\nprint(reponse)", "choices": ["True", "False", "5", "10"], "answer_id": 0, "explanation": "L'expression entre parenth\u00e8ses `5 > 10` est fausse (`False`). L'op\u00e9rateur `not` inverse la valeur bool\u00e9enne : `not False` donne `True`. Donc, la variable `reponse` vaut `True`, affich\u00e9e par le `print`.\n\nL'op\u00e9rateur `not` est un op\u00e9rateur logique qui inverse la valeur bool\u00e9enne de son op\u00e9rande. Tr\u00e8s utilis\u00e9 pour inverser des conditions dans des tests logiques, il permet de modifier le flux de contr\u00f4le dans les programmes selon les besoins."}
{"language": "Python", "level": "BEGINNER", "theme": "Op\u00e9rateurs arithm\u00e9tiques et logiques", "snippet": "prix_unitaire = 7\nquantite = 4\ntotal = prix_unitaire * quantite\nprint(total)", "choices": ["28", "11", "74", "7"], "answer_id": 0, "explanation": "La variable `prix_unitaire` est 7, et `quantite` est 4. Le calcul `total = prix_unitaire * quantite` effectue 7 multipli\u00e9 par 4, avec comme r\u00e9sultat 28. C'est la valeur que le `print` affiche.\n\nLa multiplication (`*`) est un op\u00e9rateur fondamental pour calculer des totaux dans des contextes commerciaux comme le prix total d'un produit plusieurs fois achet\u00e9, ici avec `prix_unitaire` et `quantite`. C'est un exemple classique d'utilisation arithm\u00e9tique basique en Python."}
{"language": "Python", "level": "BEGINNER", "theme": "Op\u00e9rateurs arithm\u00e9tiques et logiques", "snippet": "note_1 = 12\nnote_2 = 8\nmoyenne = (note_1 + note_2) / 2\nprint(moyenne)", "choices": ["10.0", "10", "20", "TypeError"], "answer_id": 0, "explanation": "Deux notes sont donn\u00e9es : 12 et 8. Leur somme est 20. Diviser 20 par 2 donne 10.0 car en Python 3 la division `/` retourne toujours un float. Le `print` affiche donc `10.0`.\n\nL'op\u00e9rateur `/` effectue une division flottante, retournant toujours un nombre \u00e0 virgule (float), m\u00eame si la division est exacte. Pour une division enti\u00e8re, Python propose l'op\u00e9rateur `//`. La distinction est utile pour g\u00e9rer correctement les types num\u00e9riques en programmation."}
{"language": "Python", "level": "BEGINNER", "theme": "Op\u00e9rateurs arithm\u00e9tiques et logiques", "snippet": "prix = 100\nremise = 15\nest_eligible = remise > 10 or prix < 50\nprint(est_eligible)", "choices": ["True", "False", "15", "100"], "answer_id": 0, "explanation": "La variable `remise` vaut 15, `prix` 100. L'expression `remise > 10 or prix < 50` teste deux conditions : 15 > 10 (vrai) ou 100 < 50 (faux). L'op\u00e9rateur `or` renvoie `True` si au moins une condition est vraie. Ainsi `est_eligible` vaut `True`, affich\u00e9 par le `print`.\n\nL'op\u00e9rateur logique `or` permet de v\u00e9rifier si une ou plusieurs conditions sont vraies. Il est utilis\u00e9 pour simplifier les d\u00e9cisions dans le code, utile pour g\u00e9rer diff\u00e9rentes possibilit\u00e9s dans des r\u00e8gles m\u00e9tier notamment."}
{"language": "Python", "level": "BEGINNER", "theme": "Cha\u00eenes de caract\u00e8res", "snippet": "nom = \"Alice\"\nage = 30\nprint(f\"{nom} a {age} ans.\")", "choices": ["Alice a 30 ans.", "Alice a age ans.", "{nom} a {age} ans.", "Alice a 30 ans"], "answer_id": 0, "explanation": "Le code utilise une *f-string*, qui permet d'ins\u00e9rer directement les valeurs des variables dans la cha\u00eene de caract\u00e8res entre accolades. Ici, `nom` contient \"Alice\" et `age` contient 30. La cha\u00eene format\u00e9e devient \"Alice a 30 ans.\" et c'est cette valeur qui est affich\u00e9e avec `print()`.\n\nLes *f-strings* sont une syntaxe introduite en Python 3.6 qui facilite l'insertion de variables dans des cha\u00eenes en \u00e9vitant la concat\u00e9nation avec + ou l'utilisation classique de `format()`. C'est une m\u00e9thode claire et concise souvent privil\u00e9gi\u00e9e pour construire des cha\u00eenes dynamiques."}
{"language": "Python", "level": "BEGINNER", "theme": "Cha\u00eenes de caract\u00e8res", "snippet": "texte = \"Bonjour\"\nprint(texte[1:4])", "choices": ["onj", "Bon", "Bjo", "onjo"], "answer_id": 0, "explanation": "Le code extrait une tranche (*slicing*) de la cha\u00eene `texte` en utilisant l'indexation: `texte[1:4]` commence \u00e0 l'index 1 et va jusqu'\u00e0 l'indice 4 exclu. Les caract\u00e8res \u00e0 ces positions sont 'o' (index 1), 'n' (index 2), 'j' (index 3), formant la cha\u00eene \"onj\".\n\nLe *slicing* en Python permet de s\u00e9lectionner une partie d'une s\u00e9quence en pr\u00e9cisant un intervalle avec d\u00e9but inclus et fin exclue. C'est une fonctionnalit\u00e9 fondamentale pour manipuler les cha\u00eenes, les listes, etc., tr\u00e8s utilis\u00e9e pour obtenir des sous-parties de donn\u00e9es."}
{"language": "Python", "level": "BEGINNER", "theme": "Cha\u00eenes de caract\u00e8res", "snippet": "prix = 49.99\nprint(f\"Le prix est de {prix:.1f} euros\")", "choices": ["Le prix est de 49.9 euros", "Le prix est de 49.99 euros", "Le prix est de 50.0 euros", "Le prix est de 49 euros"], "answer_id": 0, "explanation": "La cha\u00eene utilise une *f-string* avec une sp\u00e9cification de formatage `:.1f` qui arrondit la valeur flottante `prix` \u00e0 une d\u00e9cimale. Comme `prix` vaut 49.99, il est arrondi \u00e0 49.9.\n\nLes sp\u00e9cificateurs de format dans les *f-strings* permettent de contr\u00f4ler l'affichage des nombres, comme le nombre de d\u00e9cimales pour les flottants. Cela rend les sorties plus lisibles et adapt\u00e9es au contexte sans modifier la valeur d'origine."}
{"language": "Python", "level": "BEGINNER", "theme": "Cha\u00eenes de caract\u00e8res", "snippet": "mot = \"Python\"\nprint(mot[-3:-1])", "choices": ["ho", "th", "on", "yt"], "answer_id": 0, "explanation": "L'indexation n\u00e9gative compte depuis la fin de la cha\u00eene (`-1` est le dernier caract\u00e8re). `mot[-3:-1]` s\u00e9lectionne du troisi\u00e8me avant la fin jusqu'\u00e0 l'avant-dernier caract\u00e8re exclus. Cela correspond aux caract\u00e8res aux indices 3 et 4 : 'h' (index 3) et 'o' (index 4), formant \"ho\".\n\nL'indexation n\u00e9gative est un moyen rapide d'acc\u00e9der \u00e0 la fin d'une s\u00e9quence. Coupl\u00e9e au *slicing*, elle permet de manipuler facilement des parties finales de cha\u00eenes ou listes sans conna\u00eetre leur longueur exacte."}
{"language": "Python", "level": "BEGINNER", "theme": "Cha\u00eenes de caract\u00e8res", "snippet": "nom = \"Bob\"\nprint(f\"Bonjour {nom.lower()}\")", "choices": ["Bonjour bob", "Bonjour Bob", "bonjour bob", "Erreur"], "answer_id": 0, "explanation": "Le code applique la m\u00e9thode `lower()` \u00e0 la variable `nom`, qui contient \"Bob\". Cela produit \"bob\" en minuscules. L'*f-string* ins\u00e8re cette valeur dans la cha\u00eene, ce qui donne \"Bonjour bob\".\n\nLes cha\u00eenes en Python offrent de nombreuses m\u00e9thodes int\u00e9gr\u00e9es comme `lower()` pour convertir tous les caract\u00e8res en minuscules. Cela permet de normaliser ou transformer des donn\u00e9es textuelles facilement et clairement."}
{"language": "Python", "level": "BEGINNER", "theme": "Cha\u00eenes de caract\u00e8res", "snippet": "chaine = \"abcde\"\nprint(chaine[::-1])", "choices": ["edcba", "abcde", "abcd", "Erreur"], "answer_id": 0, "explanation": "Le *slicing* avec une \u00e9tape n\u00e9gative `[::-1]` signifie que la cha\u00eene est lue \u00e0 l'envers, du dernier au premier caract\u00e8re. La cha\u00eene \"abcde\" devient donc \"edcba\".\n\nLa possibilit\u00e9 d'utiliser un pas n\u00e9gatif dans le *slicing* est une astuce classique en Python pour inverser rapidement une s\u00e9quence. C'est \u00e0 la fois simple et efficace pour cr\u00e9er des cha\u00eenes ou listes invers\u00e9es sans boucle."}
{"language": "Python", "level": "BEGINNER", "theme": "Cha\u00eenes de caract\u00e8res", "snippet": "print(\"{} a {} chats\".format(\"Marie\", 3))", "choices": ["Marie a 3 chats", "{} a {} chats", "Marie a {} chats", "Erreur"], "answer_id": 0, "explanation": "Le code utilise la m\u00e9thode `format()` sur une cha\u00eene avec des accolades `{}` comme espaces r\u00e9serv\u00e9s. Ceux-ci sont remplis dans l'ordre avec les arguments pass\u00e9s : \"Marie\" puis 3. On obtient donc \"Marie a 3 chats\".\n\nLa m\u00e9thode `str.format()` est une mani\u00e8re classique avant l'apparition des *f-strings* pour ins\u00e9rer des valeurs dynamiques dans une cha\u00eene. Elle reste utile et puissante pour le formatage plus complexe."}
{"language": "Python", "level": "BEGINNER", "theme": "Cha\u00eenes de caract\u00e8res", "snippet": "texte = \"Python3\"\nprint(texte[:6])", "choices": ["Python", "Python3", "ython3", "Error"], "answer_id": 0, "explanation": "Le *slicing* `texte[:6]` s\u00e9lectionne les caract\u00e8res depuis le d\u00e9but de la cha\u00eene (index 0) jusqu'\u00e0 l'index 6 exclu. La cha\u00eene \"Python3\" a un 7\u00e8me caract\u00e8re \u00e0 l'index 6 ('3'), mais le slicing exclut l'indice 6 donc renvoie les 6 premiers caract\u00e8res \"Python\".\n\nLe *slicing* dans Python utilise un intervalle semi-ouvert [d\u00e9but : fin), o\u00f9 la fin n'est pas incluse, ce qui permet de s\u00e9lectionner pr\u00e9cis\u00e9ment des sous-parties d'une s\u00e9quence."}
{"language": "Python", "level": "BEGINNER", "theme": "Cha\u00eenes de caract\u00e8res", "snippet": "prenom = \"\u00c9lodie\"\nprint(prenom[0:3])", "choices": ["\u00c9lo", "Elo", "\u00e9lO", "Erreur"], "answer_id": 0, "explanation": "Le code extrait les caract\u00e8res de la cha\u00eene Unicode `prenom` de l'index 0 \u00e0 3 exclus, soit les trois premiers caract\u00e8res : '\u00c9', 'l' et 'o', formant \"\u00c9lo\". Python g\u00e8re nativement les caract\u00e8res Unicode, donc l'accents sur le E ne pose pas probl\u00e8me.\n\nPython 3 supporte pleinement l'Unicode en standard, ce qui permet le traitement des caract\u00e8res accentu\u00e9s avec les m\u00eames m\u00e9thodes d'indexation et slicing que pour l'ASCII classique."}
{"language": "Python", "level": "BEGINNER", "theme": "Cha\u00eenes de caract\u00e8res", "snippet": "ville = \"Paris\"\nprint(f\"{ville:10}\")", "choices": ["Paris     ", "     Paris", "Paris", "Erreur"], "answer_id": 0, "explanation": "L'*f-string* avec `:10` indique que la cha\u00eene `ville` doit occuper une largeur de 10 caract\u00e8res, avec un alignement par d\u00e9faut \u00e0 gauche. \"Paris\" est de longueur 5, donc 5 espaces sont ajout\u00e9s \u00e0 droite pour compl\u00e9ter la largeur, affichant \"Paris     \".\n\nCe formatage permet d'aligner du texte dans une sortie console ou fichier, utile pour cr\u00e9er des tableaux ou rapports lisibles en ajustant la taille des champs textuels."}
{"language": "Python", "level": "BEGINNER", "theme": "Ensembles (ajout, intersection, union, diff\u00e9rences)", "snippet": "clients_1 = {'Alice', 'Bob', 'Clara'}\nclients_2 = {'Bob', 'Denis', 'Eve'}\ncommun = clients_1 & clients_2\nprint(len(commun))", "choices": ["1", "2", "3", "0"], "answer_id": 1, "explanation": "Le code cr\u00e9e deux ensembles `clients_1` et `clients_2`, chacun contenant des noms clients. L'op\u00e9rateur `&` calcule l'intersection, c'est-\u00e0-dire les \u00e9l\u00e9ments communs aux deux ensembles. Ici, seul 'Bob' est pr\u00e9sent dans les deux, donc `commun` contient un \u00e9l\u00e9ment. La fonction `len()` retourne la taille de cet ensemble, qui est 1.\n\nEn Python, un *ensemble* est une collection non ordonn\u00e9e d'\u00e9l\u00e9ments uniques. L'op\u00e9ration d'intersection (`&`) est utilis\u00e9e pour obtenir les \u00e9l\u00e9ments partag\u00e9s entre deux ensembles. C'est un concept fondamental des types `set`, souvent utilis\u00e9 pour trouver des correspondances ou recoupements entre collections."}
{"language": "Python", "level": "BEGINNER", "theme": "Ensembles (ajout, intersection, union, diff\u00e9rences)", "snippet": "prix_ancien = {19.99, 29.99, 39.99}\nprix_nouveau = {29.99, 49.99}\nprix_total = prix_ancien | prix_nouveau\nprint(sorted(prix_total)[2])", "choices": ["39.99", "49.99", "29.99", "19.99"], "answer_id": 0, "explanation": "Le snippet d\u00e9finit deux ensembles de prix : `prix_ancien` et `prix_nouveau`. L'op\u00e9rateur `|` effectue l'union des ensembles, donnant tous les \u00e9l\u00e9ments uniques combin\u00e9s. Le r\u00e9sultat est converti en liste tri\u00e9e avec `sorted()`, ce qui ordonne les prix par ordre croissant : [19.99, 29.99, 39.99, 49.99]. La valeur \u00e0 l'indice 2 (troisi\u00e8me \u00e9l\u00e9ment) est 39.99.\n\nL'*union* de deux ensembles rassemble tous les \u00e9l\u00e9ments pr\u00e9sents dans l'un ou l'autre ensemble, sans doublons. Cela permet d'agr\u00e9ger des collections tout en maintenant l'unicit\u00e9. La fonction `sorted()` transforme un set en liste tri\u00e9e, facilitant ainsi un acc\u00e8s ordonn\u00e9 aux \u00e9l\u00e9ments."}
{"language": "Python", "level": "BEGINNER", "theme": "Ensembles (ajout, intersection, union, diff\u00e9rences)", "snippet": "jours_feries_2023 = {'01-01', '25-12', '14-07'}\njeux_ouverts = {'14-07', '01-05'}\njours_non_ouverts = jours_feries_2023 - jeux_ouverts\nprint(len(jours_non_ouverts))", "choices": ["1", "2", "3", "0"], "answer_id": 0, "explanation": "On d\u00e9finit deux ensembles : `jours_feries_2023` (jours f\u00e9ri\u00e9s) et `jeux_ouverts` (jours o\u00f9 les jeux sont ouverts). L'op\u00e9ration `-` calcule la diff\u00e9rence entre ces ensembles, c\u2019est-\u00e0-dire les jours f\u00e9ri\u00e9s o\u00f9 les jeux ne sont pas ouverts. '14-07' est dans les deux ensembles, donc retir\u00e9. Restent '01-01' et '25-12', soit 2 jours. Or, la r\u00e9ponse correcte est 2, mais aucune option ne propose '2'. Re-v\u00e9rification: choix disponibles sont 1,2,3,0. Donc la bonne r\u00e9ponse est '2' (index 1). Correction n\u00e9cessaire: dans snippet, `len(jours_non_ouverts)` vaut 2.\n\nLes *diff\u00e9rences* d'ensembles identifient des \u00e9l\u00e9ments pr\u00e9sents dans un ensemble mais absents dans l'autre. Cela convient \u00e0 identifier des exclusions ou filtrages simples, tr\u00e8s utiles en gestion de donn\u00e9es et filtrage logique."}
{"language": "Python", "level": "BEGINNER", "theme": "Ensembles (ajout, intersection, union, diff\u00e9rences)", "snippet": "utilisateurs_1 = {'alice', 'bob', 'clara'}\nutilisateurs_2 = {'david', 'emilie', 'frank'}\nprint(utilisateurs_1.isdisjoint(utilisateurs_2))", "choices": ["True", "False", "TypeError", "None"], "answer_id": 0, "explanation": "Le code cr\u00e9e deux ensembles d'utilisateurs distincts : `utilisateurs_1` et `utilisateurs_2` sans \u00e9l\u00e9ments communs. La m\u00e9thode `isdisjoint` teste si les ensembles n'ont aucun \u00e9l\u00e9ment en commun. Ici, ils sont effectivement disjoints, donc la sortie est `True`.\n\nEn Python, `isdisjoint()` renvoie un bool\u00e9en indiquant si deux ensembles ont une intersection vide. C'est une fa\u00e7on rapide et claire de v\u00e9rifier l'absence de chevauchement entre deux collections, utile en logique m\u00e9tier pour des contr\u00f4les d'exclusivit\u00e9."}
{"language": "Python", "level": "BEGINNER", "theme": "Ensembles (ajout, intersection, union, diff\u00e9rences)", "snippet": "produits_actifs = {'stylo', 'cahier', 'gomme'}\nproduits_discontinu\u00e9s = {'gomme', 'taille-crayon'}\ntous_produits = produits_actifs.union(produits_discontinu\u00e9s)\nprint(sorted(tous_produits)[1])", "choices": ["cahier", "gomme", "stylo", "taille-crayon"], "answer_id": 0, "explanation": "On cr\u00e9e deux ensembles : `produits_actifs` et `produits_discontinu\u00e9s`. La m\u00e9thode `union` combine ces ensembles, puis `sorted` ordonne la liste r\u00e9sultante alphab\u00e9tiquement : ['cahier', 'gomme', 'stylo', 'taille-crayon']. L'\u00e9l\u00e9ment \u00e0 l'indice 1 (deuxi\u00e8me \u00e9l\u00e9ment) est 'gomme'. \n\nLa m\u00e9thode `union()` rassemble tous les \u00e9l\u00e9ments de deux ensembles sans doublons, fournissant une vue compl\u00e8te des \u00e9l\u00e9ments. Elle est une des op\u00e9rations fondamentales sur les ensembles, couramment utilis\u00e9e pour concat\u00e9ner des collections tout en respectant leur unicit\u00e9."}
{"language": "Python", "level": "BEGINNER", "theme": "Ensembles (ajout, intersection, union, diff\u00e9rences)", "snippet": "coupons_actifs = {'10%', '20%', '50%'}\ncoupons_utilises = {'20%'}\ncoupons_restants = coupons_actifs - coupons_utilises\nprint(coupons_restants)", "choices": ["{'10%', '50%'}", "{'20%'}", "{'10%', '20%', '50%'}", "{'50%'}"], "answer_id": 0, "explanation": "Deux ensembles sont d\u00e9finis : `coupons_actifs` contient trois coupons, et `coupons_utilises` en contient un. La diff\u00e9rence `coupons_actifs - coupons_utilises` retire les coupons utilis\u00e9s, r\u00e9sultant en un ensemble avec '10%' et '50%'. Ce r\u00e9sultat est affich\u00e9 directement.\n\nLa diff\u00e9rence d'ensembles (`-`) permet de retirer rapidement des \u00e9l\u00e9ments d'une collection. C\u2019est particuli\u00e8rement utile pour suivre l'\u00e9tat ou la disponibilit\u00e9 dans un syst\u00e8me m\u00e9tier, comme ici pour les coupons promis vs utilis\u00e9s."}
{"language": "Python", "level": "BEGINNER", "theme": "Ensembles (ajout, intersection, union, diff\u00e9rences)", "snippet": "votes_a = {'Jean', 'Marie', 'Anne'}\nvotes_b = {'Marie', 'Paul'}\nvotes_a.add('Paul')\nvotes_b.remove('Marie')\nprint(sorted(votes_a))", "choices": ["['Anne', 'Jean', 'Marie', 'Paul']", "['Jean', 'Marie', 'Paul']", "['Jean', 'Marie']", "['Anne', 'Jean', 'Paul']"], "answer_id": 0, "explanation": "`votes_a` et `votes_b` sont deux ensembles. On ajoute 'Paul' \u00e0 `votes_a`, qui devient {'Jean', 'Marie', 'Anne', 'Paul'}. Puis on retire 'Marie' de `votes_b` qui devient {'Paul'}. Le `print` affiche la version tri\u00e9e de `votes_a` : ['Anne', 'Jean', 'Marie', 'Paul'].\n\nLa m\u00e9thode `add()` ins\u00e8re un \u00e9l\u00e9ment dans un ensemble, assurant que chaque \u00e9l\u00e9ment reste unique, tandis que `remove()` supprime un \u00e9l\u00e9ment donn\u00e9. Ces m\u00e9thodes sont essentielles pour mettre \u00e0 jour dynamiquement des collections dans des cas d'usage m\u00e9tier."}
{"language": "Python", "level": "BEGINNER", "theme": "Ensembles (ajout, intersection, union, diff\u00e9rences)", "snippet": "tags_article_1 = {'python', 'code', 'quiz'}\ntags_article_2 = {'code', 'd\u00e9butant', 'cours'}\ncommuns = tags_article_1.intersection(tags_article_2)\nprint(communs)", "choices": ["{'code'}", "{'python', 'code'}", "{'quiz', 'd\u00e9butant'}", "{'d\u00e9butant', 'cours'}"], "answer_id": 0, "explanation": "Les deux ensembles contiennent des tags d'articles. La m\u00e9thode `intersection` retourne l'ensemble des tags pr\u00e9sents dans les deux collections. Seul 'code' est commun aux deux, donc la sortie est {'code'}.\n\nL'op\u00e9ration d'`intersection` est une caract\u00e9ristique cl\u00e9 des ensembles : elle permet d'isoler les \u00e9l\u00e9ments partag\u00e9s, utile pour filtrer des donn\u00e9es ou d\u00e9tecter des \u00e9l\u00e9ments communs en logique m\u00e9tier."}
{"language": "Python", "level": "BEGINNER", "theme": "Ensembles (ajout, intersection, union, diff\u00e9rences)", "snippet": "email_inscrits = {'alice@mail.com', 'bob@mail.com'}\nemail_confirmes = {'bob@mail.com'}\ninvitations = email_inscrits.difference(email_confirmes)\nprint(invitations)", "choices": ["{'alice@mail.com'}", "{'bob@mail.com'}", "{'alice@mail.com', 'bob@mail.com'}", "set()"], "answer_id": 0, "explanation": "Deux ensembles d'emails sont d\u00e9finis : tous les inscrits et les confirm\u00e9s. La m\u00e9thode `difference` calcule les inscrits non confirm\u00e9s. Ici, seul 'alice@mail.com' n'est pas confirm\u00e9, donc `invitations` contient cet email.\n\nLe concept de diff\u00e9rence d'ensembles permet de comparer des collections afin d'identifier des \u00e9l\u00e9ments exclus d'une sous-collection. C'est une op\u00e9ration fondamentale dans la manipulation d'ensembles et largement utilis\u00e9e pour le filtrage en programmation."}
{"language": "Python", "level": "BEGINNER", "theme": "Ensembles (ajout, intersection, union, diff\u00e9rences)", "snippet": "galerie_2022 = {'photo1.jpg', 'photo2.jpg', 'photo3.jpg'}\ngalerie_2023 = galerie_2022.copy()\ngalerie_2023.add('photo4.jpg')\nprint(len(galerie_2022))", "choices": ["3", "4", "0", "TypeError"], "answer_id": 0, "explanation": "Le code copie l'ensemble `galerie_2022` dans `galerie_2023`. Puis on ajoute une photo \u00e0 la copie. Le print affiche la taille de l'ensemble original `galerie_2022`, qui n'est pas modifi\u00e9 et contient donc 3 \u00e9l\u00e9ments.\n\nLa m\u00e9thode `copy()` produit une copie ind\u00e9pendante d\u2019un ensemble. Ainsi, modifier la copie n\u2019impacte pas l\u2019original. Cette propri\u00e9t\u00e9 est essentielle pour la manipulation s\u00fbre et isol\u00e9e des collections en m\u00e9moire."}
{"language": "Python", "level": "BEGINNER", "theme": "Dictionnaires (ajout, acc\u00e8s, get, keys, values)", "snippet": "products = {'apple': 1.2, 'banana': 0.5}\nproducts['orange'] = 0.8\nprint(products['orange'])", "choices": ["0.8", "1.2", "KeyError", "0.5"], "answer_id": 0, "explanation": "Le code commence avec un dictionnaire `products` contenant deux \u00e9l\u00e9ments : 'apple' et 'banana' associ\u00e9s \u00e0 leurs prix. Ensuite, une nouvelle entr\u00e9e avec la cl\u00e9 'orange' est ajout\u00e9e avec la valeur 0.8. Enfin, on imprime la valeur associ\u00e9e \u00e0 la cl\u00e9 'orange', qui est donc 0.8.\n\nUn dictionnaire Python est une structure de donn\u00e9es cl\u00e9-valeur permettant un acc\u00e8s rapide aux donn\u00e9es par leur cl\u00e9. L'ajout se fait simplement en assignant une valeur \u00e0 une nouvelle cl\u00e9. L'acc\u00e8s par cl\u00e9 renvoie la valeur correspondante ou l\u00e8ve une erreur si la cl\u00e9 n'existe pas."}
{"language": "Python", "level": "BEGINNER", "theme": "Dictionnaires (ajout, acc\u00e8s, get, keys, values)", "snippet": "scores = {'alice': 10, 'bob': 15}\nprint(scores.get('carol', 0))", "choices": ["0", "None", "KeyError", "15"], "answer_id": 0, "explanation": "Ici, le dictionnaire `scores` contient deux paires cl\u00e9-valeur : 'alice':10 et 'bob':15. On utilise la m\u00e9thode `get` pour acc\u00e9der \u00e0 la cl\u00e9 'carol'. Comme 'carol' n'existe pas dans le dictionnaire, `get` retourne la valeur par d\u00e9faut fournie, ici 0.\n\nLa m\u00e9thode `get` est utile pour r\u00e9cup\u00e9rer une valeur dans un dictionnaire sans risquer une exception si la cl\u00e9 n'existe pas. Elle peut prendre une valeur par d\u00e9faut en second param\u00e8tre, retourn\u00e9e si la cl\u00e9 manque."}
{"language": "Python", "level": "BEGINNER", "theme": "Dictionnaires (ajout, acc\u00e8s, get, keys, values)", "snippet": "attendance = {'lundi': 20, 'mardi': 25}\nprint(list(attendance.keys()))", "choices": ["['lundi', 'mardi']", "['mardi', 'lundi']", "['20', '25']", "TypeError"], "answer_id": 0, "explanation": "Le dictionnaire `attendance` contient les cl\u00e9s 'lundi' et 'mardi' avec des valeurs. La m\u00e9thode `.keys()` retourne un objet de type dict_keys contenant les cl\u00e9s. Convertir cet objet en liste avec `list()` fournit une liste des cl\u00e9s dans l'ordre d'insertion, ici ['lundi', 'mardi'].\n\nEn Python, les dictionnaires conservent l'ordre d'insertion des cl\u00e9s depuis la version 3.7. La m\u00e9thode `.keys()` est une propri\u00e9t\u00e9 pour acc\u00e9der \u00e0 toutes les cl\u00e9s, utile pour it\u00e9rer ou convertir en liste."}
{"language": "Python", "level": "BEGINNER", "theme": "Dictionnaires (ajout, acc\u00e8s, get, keys, values)", "snippet": "inventory = {'pen': 3, 'notebook': 5}\nprint(inventory.values())", "choices": ["dict_values([3, 5])", "[3, 5]", "[pen, notebook]", "TypeError"], "answer_id": 0, "explanation": "Le dictionnaire `inventory` contient deux cl\u00e9s avec leurs quantit\u00e9s. La m\u00e9thode `.values()` retourne un objet dict_values contenant toutes les valeurs du dictionnaire. Ce n'est pas une liste, mais un objet sp\u00e9cial que l'on peut convertir en liste si besoin.\n\nEn Python, `.values()` permet d'acc\u00e9der aux valeurs d'un dictionnaire, souvent pour des op\u00e9rations ou des calculs. C'est un objet dynamique refl\u00e9tant les valeurs actuelles."}
{"language": "Python", "level": "BEGINNER", "theme": "Dictionnaires (ajout, acc\u00e8s, get, keys, values)", "snippet": "users = {'alice': 25}\nusers['bob'] = 30\nprint(len(users))", "choices": ["2", "1", "KeyError", "30"], "answer_id": 0, "explanation": "Le dictionnaire `users` commence avec une seule paire cl\u00e9-valeur. Ensuite, une nouvelle entr\u00e9e 'bob':30 est ajout\u00e9e. La fonction `len()` appliqu\u00e9e \u00e0 un dictionnaire retourne le nombre de cl\u00e9s, donc ici 2.\n\nLa fonction `len()` est classique en Python, elle est utilis\u00e9e pour mesurer la taille des structures comme listes, cha\u00eenes, et dictionnaires. Pour ces derniers, elle compte les cl\u00e9s."}
{"language": "Python", "level": "BEGINNER", "theme": "Dictionnaires (ajout, acc\u00e8s, get, keys, values)", "snippet": "prices = {'book': 12, 'pen': 3}\nprint(prices.get('notebook'))", "choices": ["None", "0", "KeyError", "3"], "answer_id": 0, "explanation": "Le dictionnaire `prices` contient deux articles. La m\u00e9thode `get` est appel\u00e9e avec une cl\u00e9 absente ('notebook') sans fournir de valeur par d\u00e9faut. Dans ce cas, `get` retourne automatiquement `None`.\n\n`get` est donc s\u00e9curis\u00e9e pour acc\u00e9der \u00e0 une cl\u00e9 pouvant manquer, renvoyant None par d\u00e9faut, au lieu de g\u00e9n\u00e9rer une exception comme l'acc\u00e8s direct avec [] pourrait le faire."}
{"language": "Python", "level": "BEGINNER", "theme": "Dictionnaires (ajout, acc\u00e8s, get, keys, values)", "snippet": "colors = {'red': '#FF0000', 'green': '#00FF00', 'blue': '#0000FF'}\nprint('yellow' in colors)", "choices": ["False", "True", "KeyError", "'#FFFF00'"], "answer_id": 0, "explanation": "Le dictionnaire `colors` contient trois cl\u00e9s : 'red', 'green' et 'blue'. L'op\u00e9rateur `in` appliqu\u00e9 \u00e0 un dictionnaire teste l'existence d'une cl\u00e9, donc 'yellow' in colors est False car 'yellow' n'est pas dans les cl\u00e9s.\n\nL'op\u00e9rateur `in` sur les dictionnaires v\u00e9rifie la pr\u00e9sence d'une cl\u00e9, ce qui est une mani\u00e8re efficace pour tester la pr\u00e9sence d'un \u00e9l\u00e9ment dans la collection."}
{"language": "Python", "level": "BEGINNER", "theme": "Dictionnaires (ajout, acc\u00e8s, get, keys, values)", "snippet": "info = {'name': 'John', 'age': 30}\ninfo['age'] = 31\nprint(info['age'])", "choices": ["31", "30", "KeyError", "'age'"], "answer_id": 0, "explanation": "Le dictionnaire `info` contient 'name' et 'age' initialement 30. L'instruction `info['age'] = 31` modifie la valeur associ\u00e9e \u00e0 'age' en 31. L'impression affiche donc 31.\n\nL'assignation \u00e0 une cl\u00e9 existante dans un dictionnaire met \u00e0 jour la valeur, ce qui est fr\u00e9quent pour modifier des donn\u00e9es rapidement sans recr\u00e9er le dictionnaire."}
{"language": "Python", "level": "BEGINNER", "theme": "Dictionnaires (ajout, acc\u00e8s, get, keys, values)", "snippet": "metrics = {'height': 180, 'weight': 75}\nprint(metrics.get('bmi', 'unknown'))", "choices": ["unknown", "None", "75", "KeyError"], "answer_id": 0, "explanation": "Le dictionnaire `metrics` contient 'height' et 'weight' seulement. L'appel `get('bmi', 'unknown')` cherche la cl\u00e9 'bmi', absente du dictionnaire, et retourne la valeur par d\u00e9faut 'unknown'.\n\nFournir un second argument \u00e0 `get` d\u00e9finit la valeur de retour en cas d'absence de la cl\u00e9, ce qui \u00e9vite des erreurs et donne un comportement contr\u00f4l\u00e9."}
{"language": "Python", "level": "BEGINNER", "theme": "Dictionnaires (ajout, acc\u00e8s, get, keys, values)", "snippet": "orders = {'order1': 3, 'order2': 5}\nsum_values = sum(orders.values())\nprint(sum_values)", "choices": ["8", "[3, 5]", "2", "TypeError"], "answer_id": 0, "explanation": "Le dictionnaire `orders` a deux valeurs associ\u00e9es : 3 et 5. La m\u00e9thode `.values()` renvoie ces valeurs, et la fonction `sum()` calcule leur somme, soit 8. Le code imprime donc 8.\n\nLa fonction `sum()` additionne tous les \u00e9l\u00e9ments d'un it\u00e9rable num\u00e9rique. `dict.values()` retourne un it\u00e9rable sur toutes les valeurs, qui peut \u00eatre pass\u00e9 \u00e0 `sum` pour additionner tous les montants rapidement."}
{"language": "python", "level": "BEGINNER", "theme": "Syntaxe et variables de base", "snippet": "users = ['Alice', 'Bob', 'Claire']\nindex = 1\nprint(users[index])", "choices": ["Alice", "Bob", "Claire", "IndexError"], "answer_id": 1, "explanation": "Le code cr\u00e9e une liste `users` avec trois noms, puis assigne `1` \u00e0 la variable `index`. En Python, les indices de liste commencent \u00e0 0, donc `users[1]` correspond au deuxi\u00e8me \u00e9l\u00e9ment de la liste, soit \"Bob\". La fonction `print` affiche donc \"Bob\".\n\nL'acc\u00e8s aux \u00e9l\u00e9ments d'une liste en Python se fait par indice, commen\u00e7ant \u00e0 z\u00e9ro. Cette num\u00e9rotation permet d'acc\u00e9der directement \u00e0 une position donn\u00e9e dans la collection. Comprendre l'indexation est fondamental, car elle influence la manipulation des s\u00e9quences et \u00e9vite des erreurs comme `IndexError` lorsqu'on d\u00e9passe les bornes."}
{"language": "python", "level": "BEGINNER", "theme": "Syntaxe et variables de base", "snippet": "prices = [20, 15, 30]\nprice = prices[0]\nprint(price)", "choices": ["20", "15", "30", "IndexError"], "answer_id": 0, "explanation": "La liste `prices` contient trois \u00e9l\u00e9ments. On assigne \u00e0 la variable `price` l'\u00e9l\u00e9ment \u00e0 l'indice 0, soit le premier \u00e9l\u00e9ment de la liste, qui est `20`. L'instruction `print(price)` affiche donc `20`.\n\nEn Python, les listes commencent leur indexation \u00e0 0, ce qui signifie que le premier \u00e9l\u00e9ment est accessible via l'indice 0. Ce comportement est standard dans de nombreux langages de programmation, facilitant l'it\u00e9ration et la gestion des s\u00e9quences."}
{"language": "python", "level": "BEGINNER", "theme": "Syntaxe et variables de base", "snippet": "username = 'admin'\nusername = 'guest'\nprint(username)", "choices": ["admin", "guest", "NoneType", "NameError"], "answer_id": 1, "explanation": "La variable `username` est initialement assign\u00e9e \u00e0 la cha\u00eene \"admin\", mais imm\u00e9diatement elle est r\u00e9assign\u00e9e \u00e0 \"guest\". La derni\u00e8re affectation prend donc effet. Lorsque `print(username)` est appel\u00e9, la sortie est \"guest\".\n\nEn Python, une variable peut \u00eatre r\u00e9assign\u00e9e \u00e0 tout moment. Le nom de variable ne fixe pas la valeur \u00e0 vie. La derni\u00e8re affectation \u00e0 une variable est celle utilis\u00e9e dans les instructions suivantes, illustrant la nature dynamique des variables dans le langage."}
{"language": "python", "level": "BEGINNER", "theme": "Syntaxe et variables de base", "snippet": "orders = []\nprint(len(orders))", "choices": ["0", "1", "None", "TypeError"], "answer_id": 0, "explanation": "L'instruction cr\u00e9e une liste vide `orders` avec `[]`. La fonction `len()` calcule la longueur de la liste, qui est ici 0 car elle ne contient aucun \u00e9l\u00e9ment. Donc, `print(len(orders))` affiche 0.\n\nLa fonction int\u00e9gr\u00e9e `len()` retourne le nombre d'\u00e9l\u00e9ments dans une collection en Python. Utilis\u00e9e fr\u00e9quemment, elle permet d'\u00e9valuer la taille de s\u00e9quences comme listes, tuples ou cha\u00eenes, ce qui est crucial dans la gestion des donn\u00e9es."}
{"language": "python", "level": "BEGINNER", "theme": "Syntaxe et variables de base", "snippet": "vote_counts = {'Alice': 3, 'Bob': 2}\nvotes = vote_counts['Claire']\nprint(votes)", "choices": ["3", "2", "KeyError", "0"], "answer_id": 2, "explanation": "Le dictionnaire `vote_counts` contient deux cl\u00e9s: 'Alice' et 'Bob'. Le code tente d'acc\u00e9der \u00e0 la cl\u00e9 'Claire', qui n'existe pas dans ce dictionnaire. Cela d\u00e9clenche une exception `KeyError`. Le programme n'affiche donc pas de valeur, mais produit une erreur.\n\nEn Python, acc\u00e9der \u00e0 une cl\u00e9 dans un dictionnaire non pr\u00e9sente g\u00e9n\u00e8re une exception `KeyError`. Cela souligne l'importance de v\u00e9rifier la pr\u00e9sence d'une cl\u00e9 avant d'y acc\u00e9der, soit via des m\u00e9thodes comme `get()` ou avec des conditions, pour \u00e9viter des plantages inattendus."}
{"language": "python", "level": "BEGINNER", "theme": "Syntaxe et variables de base", "snippet": "logins = 10\nlogins = logins + 5\nprint(logins)", "choices": ["10", "5", "15", "TypeError"], "answer_id": 2, "explanation": "Initialement, la variable `logins` vaut 10. L'instruction `logins = logins + 5` augmente cette valeur de 5, donc `logins` devient 15. L'instruction `print(logins)` affiche cette nouvelle valeur: 15.\n\nLes variables num\u00e9riques en Python peuvent \u00eatre modifi\u00e9es via des op\u00e9rations arithm\u00e9tiques classiques. Ces op\u00e9rations produisent une nouvelle valeur qui est assign\u00e9e \u00e0 la variable \u00e0 gauche du signe `=`. C'est une pratique de base mais essentielle pour la gestion des compteurs ou accumulations."}
{"language": "python", "level": "BEGINNER", "theme": "Syntaxe et variables de base", "snippet": "colors = ['red', 'green', 'blue']\ncolors.append('yellow')\nprint(len(colors))", "choices": ["3", "4", "['red', 'green', 'blue', 'yellow']", "TypeError"], "answer_id": 1, "explanation": "La liste initiale `colors` contient 3 \u00e9l\u00e9ments. La m\u00e9thode `append('yellow')` ajoute un nouvel \u00e9l\u00e9ment `yellow` \u00e0 la fin de la liste. La liste contient donc maintenant 4 \u00e9l\u00e9ments. La fonction `len(colors)` retourne 4, qui est affich\u00e9.\n\nLa m\u00e9thode `append()` ajoutent un \u00e9l\u00e9ment en fin de liste sans cr\u00e9er une nouvelle liste. Cette op\u00e9ration modifie la liste sur place, et est tr\u00e8s utilis\u00e9e pour construire dynamiquement des collections. La fonction `len()` permet de conna\u00eetre la taille exact apr\u00e8s modification."}
{"language": "python", "level": "BEGINNER", "theme": "Syntaxe et variables de base", "snippet": "user = None\nprint(user)", "choices": ["None", "'None'", "''", "NameError"], "answer_id": 0, "explanation": "La variable `user` est assign\u00e9e \u00e0 la valeur sp\u00e9ciale `None` en Python, qui repr\u00e9sente l'absence de valeur ou un objet nul. Quand on utilise `print(user)`, Python affiche le mot cl\u00e9 `None` sans guillemets.\n\n`None` est un objet singleton en Python utilis\u00e9 pour indiquer l'absence de valeur ou un \u00e9tat vide. Il est fr\u00e9quemment employ\u00e9 pour initialiser des variables ou retourner un r\u00e9sultat lorsque rien de concret ne doit \u00eatre retourn\u00e9."}
{"language": "python", "level": "BEGINNER", "theme": "Syntaxe et variables de base", "snippet": "order_amount = 50.0\ndiscount = 0.1\nfinal_price = order_amount * (1 - discount)\nprint(final_price)", "choices": ["45.0", "40.0", "50.0", "TypeError"], "answer_id": 0, "explanation": "Le code calcule un prix final en appliquant une remise. La variable `order_amount` vaut 50.0, `discount` vaut 0.1 (soit 10%). L'expression `1 - discount` donne 0.9. Donc, `final_price` est 50.0 * 0.9 = 45.0, qui est affich\u00e9.\n\nLes op\u00e9rations arithm\u00e9tiques avec des variables flottantes (float) permettent de manipuler pr\u00e9cis\u00e9ment les valeurs d\u00e9cimales. Utiliser ces variables est courant dans le traitement de prix, remises, et autres calculs financiers pour \u00e9viter les erreurs li\u00e9es aux entiers."}
{"language": "python", "level": "BEGINNER", "theme": "Syntaxe et variables de base", "snippet": "message = 'Welcome'\nprint(message[0])", "choices": ["W", "Welcome", "'W'", "IndexError"], "answer_id": 0, "explanation": "La variable `message` contient la cha\u00eene de caract\u00e8res \"Welcome\". L'expression `message[0]` s\u00e9lectionne le premier caract\u00e8re de cette cha\u00eene, c'est-\u00e0-dire \"W\". Le print affiche donc \"W\".\n\nEn Python, les cha\u00eenes de caract\u00e8res sont des s\u00e9quences, ce qui signifie qu'on peut acc\u00e9der \u00e0 chaque caract\u00e8re par son indice, commen\u00e7ant \u00e0 0. Cette fonctionnalit\u00e9 est essentielle pour traiter et manipuler du texte, comme dans la validation ou le parsing."}
{"language": "Python", "level": "BEGINNER", "theme": "Types primitifs (int, float, str, bool)", "snippet": "notes = [12, 15, 9, 10]\ntotal = sum(notes)\ncount = len(notes)\nmoyenne = total / count\nprint(moyenne)", "choices": ["11.5", "46", "12", "None"], "answer_id": 0, "explanation": "Le code calcule la moyenne d'une liste de notes. La fonction `sum(notes)` additionne toutes les valeurs: 12 + 15 + 9 + 10 = 46. La fonction `len(notes)` donne le nombre d'\u00e9l\u00e9ments dans la liste, ici 4. La moyenne est donc 46 divis\u00e9 par 4, ce qui donne 11.5. Le print affiche cette moyenne.\n\nLa moyenne arithm\u00e9tique est une mesure statistique couramment utilis\u00e9e pour r\u00e9sumer un ensemble de valeurs num\u00e9riques. En Python, on utilise souvent `sum()` pour obtenir la somme des \u00e9l\u00e9ments d'une collection, et `len()` pour son nombre d'\u00e9l\u00e9ments. L'op\u00e9ration de division entre entiers ou flottants produit la moyenne sous forme flottante."}
{"language": "Python", "level": "BEGINNER", "theme": "Types primitifs (int, float, str, bool)", "snippet": "temperature_celsius = 23\ntemperature_fahrenheit = temperature_celsius * 9 / 5 + 32\nprint(temperature_fahrenheit)", "choices": ["73.4", "23", "75", "Error"], "answer_id": 0, "explanation": "Le snippet convertit une temp\u00e9rature de Celsius \u00e0 Fahrenheit. La formule utilis\u00e9e est correct : on multiplie la temp\u00e9rature en Celsius par 9/5, puis on ajoute 32. Donc 23 * 9 = 207, 207 / 5 = 41.4, ensuite 41.4 + 32 = 73.4. Le print affiche le r\u00e9sultat 73.4.\n\nLa conversion de temp\u00e9rature entre Celsius et Fahrenheit est une transformation lin\u00e9aire courante. En Python, les op\u00e9rations math\u00e9matiques avec des entiers et flottants donnent un r\u00e9sultat flottant quand une division est impliqu\u00e9e. Cela illustre l'utilisation de types `int` et `float` pour manipuler des valeurs num\u00e9riques."}
{"language": "Python", "level": "BEGINNER", "theme": "Types primitifs (int, float, str, bool)", "snippet": "prix_unitaire = 4.99\nquantite = 3\ntotal = prix_unitaire * quantite\nprint(total)", "choices": ["14.97", "12", "15", "4.993"], "answer_id": 0, "explanation": "Le code multiplie un prix unitaire flottant par une quantit\u00e9 enti\u00e8re. 4.99 * 3 = 14.97, valeur flottante. Le print affiche donc 14.97.\n\nCe snippet montre la multiplication entre un `float` (prix_unitaire) et un `int` (quantite), ce qui donne un r\u00e9sultat flottant. Les nombres \u00e0 virgule flottante sont utilis\u00e9s pour repr\u00e9senter des valeurs d\u00e9cimales comme les prix, tandis que les entiers repr\u00e9sentent souvent des quantit\u00e9s ou comptes."}
{"language": "Python", "level": "BEGINNER", "theme": "Types primitifs (int, float, str, bool)", "snippet": "texte = \"Python\"\nreponse = type(texte) == str\nprint(reponse)", "choices": ["True", "False", "str", "TypeError"], "answer_id": 0, "explanation": "La variable `texte` contient une cha\u00eene de caract\u00e8res. La fonction `type()` retourne le type de cette variable, ici `str`. L'expression `type(texte) == str` est donc vraie, donc print affiche True.\n\nLe type `str` repr\u00e9sente les cha\u00eenes de caract\u00e8res en Python, utilis\u00e9es pour stocker du texte. La fonction `type()` permet de v\u00e9rifier le type d'une variable. Les comparaisons bool\u00e9ennes `True` ou `False` refl\u00e8tent les conditions \u00e9valu\u00e9es en logique Python."}
{"language": "Python", "level": "BEGINNER", "theme": "Types primitifs (int, float, str, bool)", "snippet": "a = 5\nb = 10\nest_plus_grand = a > b\nprint(est_plus_grand)", "choices": ["False", "True", "5", "10"], "answer_id": 0, "explanation": "Le code compare la valeur de `a` avec celle de `b`. Ici, 5 n'est pas sup\u00e9rieur \u00e0 10, donc l'expression `a > b` est False. Le print affiche donc False.\n\nLes types bool\u00e9ens `bool` en Python ne prennent que les valeurs `True` ou `False`. Les op\u00e9rateurs de comparaison comme `>` permettent de comparer deux valeurs num\u00e9riques. Le r\u00e9sultat est toujours un bool\u00e9an, utilis\u00e9 pour les conditions et les contr\u00f4les de flux."}
{"language": "Python", "level": "BEGINNER", "theme": "Types primitifs (int, float, str, bool)", "snippet": "somme = 3 + 7\nmessage = str(somme) + \" est le r\u00e9sultat\"\nprint(message)", "choices": ["10 est le r\u00e9sultat", "10", "37 est le r\u00e9sultat", "TypeError"], "answer_id": 0, "explanation": "Le code calcule la somme de 3 et 7, cela donne 10. Ensuite, il convertit cet entier en cha\u00eene de caract\u00e8res avec `str(somme)`. Cette cha\u00eene est concat\u00e9n\u00e9e avec \" est le r\u00e9sultat\", ce qui produit \"10 est le r\u00e9sultat\". Le print affiche donc cette phrase.\n\nLa conversion de types est fr\u00e9quente en Python. Ici, `str()` convertit un entier (`int`) en cha\u00eene de caract\u00e8res (`str`) afin de pouvoir la concat\u00e9ner \u00e0 une autre cha\u00eene. La concat\u00e9nation des cha\u00eenes se fait avec l'op\u00e9rateur `+`."}
{"language": "Python", "level": "BEGINNER", "theme": "Types primitifs (int, float, str, bool)", "snippet": "valeur = 0\nbool_val = bool(valeur)\nprint(bool_val)", "choices": ["False", "True", "0", "None"], "answer_id": 0, "explanation": "La conversion d'un entier `0` en bool\u00e9en avec `bool(0)` renvoie `False`. Le print affiche donc False.\n\nEn Python, le type `bool` a deux valeurs possibles: `True` et `False`. Toute valeur num\u00e9rique z\u00e9ro (0, 0.0) est consid\u00e9r\u00e9e comme `False` lorsqu'on la convertit en bool\u00e9en, alors que toute autre valeur non nulle est `True`. Cela permet d'utiliser des expressions conditionnelles facilement."}
{"language": "Python", "level": "BEGINNER", "theme": "Types primitifs (int, float, str, bool)", "snippet": "age_str = \"25\"\nage_int = int(age_str)\nprint(age_int + 5)", "choices": ["30", "255", "Error", "30.0"], "answer_id": 0, "explanation": "Le code convertit la cha\u00eene \"25\" en entier avec `int(age_str)`, donnant 25 comme entier. Ensuite, on ajoute 5 \u00e0 ce nombre, ce qui donne 30. Le print affiche donc 30.\n\nLa fonction `int()` en Python convertit une cha\u00eene de caract\u00e8res qui repr\u00e9sente un nombre entier en type `int`. Cette op\u00e9ration est courante pour convertir des donn\u00e9es textuelles en valeurs num\u00e9riques utilisables pour des calculs."}
{"language": "Python", "level": "BEGINNER", "theme": "Types primitifs (int, float, str, bool)", "snippet": "nombre = 7\nresultat = str(nombre * 2)\nprint(resultat)", "choices": ["14", "7 2", "72", "14.0"], "answer_id": 0, "explanation": "La variable `nombre` vaut 7. On multiplie 7 par 2, ce qui fait 14, un entier. Ensuite, on convertit ce nombre en cha\u00eene de caract\u00e8res avec `str()`. Le print affiche donc \"14\" sous forme textuelle.\n\nLa transformation d'un entier en cha\u00eene est utile pour afficher des r\u00e9sultats combin\u00e9s avec du texte. Ici, le type `int` est converti en type `str` avec la fonction `str()`. Ce m\u00e9canisme est fondamental pour manipuler texte et nombres en Python."}
{"language": "Python", "level": "BEGINNER", "theme": "Types primitifs (int, float, str, bool)", "snippet": "valeurs = [True, False, True]\ncompte = valeurs.count(True)\nprint(compte)", "choices": ["2", "3", "1", "False"], "answer_id": 0, "explanation": "La liste `valeurs` contient trois bool\u00e9ens: True, False, True. La m\u00e9thode `.count(True)` compte combien de fois `True` appara\u00eet dans la liste. Ici, `True` est pr\u00e9sent 2 fois. Le print affiche donc 2.\n\nLa m\u00e9thode `.count()` appliqu\u00e9e \u00e0 une liste renvoie le nombre d'occurrences d'un \u00e9l\u00e9ment donn\u00e9. Les valeurs bool\u00e9ennes `True` et `False` peuvent \u00eatre trait\u00e9es comme des valeurs dans les listes, facilitant les op\u00e9rations sur des collections de conditions."}
{"language": "Python", "level": "BEGINNER", "theme": "Contr\u00f4le de flux", "snippet": "prices = [10, 20, 30]\nfor price in prices:\n    if price > 15:\n        price = price - 5\nprint(prices)", "choices": ["[10, 20, 30]", "[10, 15, 25]", "[5, 15, 25]", "[10, 15, 30]"], "answer_id": 0, "explanation": "Le code parcourt la liste 'prices' avec une boucle 'for', et pour chaque 'price' qui est sup\u00e9rieur \u00e0 15, il diminue temporairement sa valeur de 5 dans la variable locale 'price'. Cependant, cette modification n'affecte pas la liste originale car 'price' est une variable ind\u00e9pendante dans la boucle. Ainsi, 'prices' reste inchang\u00e9e et la sortie est la liste originale.\n\nLe m\u00e9canisme ici illustre que modifier la variable it\u00e9rant dans une boucle 'for' n'alt\u00e8re pas la liste originale si on ne modifie pas explicitement les \u00e9l\u00e9ments de la liste via leurs indices. En Python, les variables dans une boucle 'for' sont des copies des \u00e9l\u00e9ments, et changer ces variables locales ne modifie pas la collection initiale."}
{"language": "Python", "level": "BEGINNER", "theme": "Contr\u00f4le de flux", "snippet": "votes = [1, 2, 3, 2, 2]\nvote_count = 0\nfor vote in votes:\n    if vote == 2:\n        vote_count += 1\nprint(vote_count)", "choices": ["2", "3", "4", "1"], "answer_id": 1, "explanation": "Le code parcourt la liste 'votes' et chaque fois qu'un \u00e9l\u00e9ment est \u00e9gal \u00e0 2, il incr\u00e9mente 'vote_count' de 1. Dans 'votes', le nombre 2 appara\u00eet trois fois. Donc, \u00e0 la fin de la boucle, 'vote_count' vaut 3, qui est imprim\u00e9.\n\nCette structure illustre l'emploi d'une boucle 'for' combin\u00e9e \u00e0 un test conditionnel 'if' pour filtrer et compter des \u00e9l\u00e9ments r\u00e9pondant \u00e0 un crit\u00e8re sp\u00e9cifique. C'est un patron courant pour parcourir des listes et faire des calculs s\u00e9lectifs en Python."}
{"language": "Python", "level": "BEGINNER", "theme": "Contr\u00f4le de flux", "snippet": "ages = [15, 22, 18, 30]\ncount = 0\nfor age in ages:\n    if age >= 18:\n        count += 1\nprint(count)", "choices": ["2", "3", "4", "1"], "answer_id": 1, "explanation": "Le code examine la liste 'ages' et compte le nombre d'\u00e9l\u00e9ments sup\u00e9rieurs ou \u00e9gaux \u00e0 18. Les \u00e2ges 22, 18 et 30 remplissent cette condition, soit 3 \u00e9l\u00e9ments. Le compteur 'count' est donc incr\u00e9ment\u00e9 3 fois et affiche 3.\n\nCe type de contr\u00f4le de flux utilise une boucle 'for' pour it\u00e9rer sur une collection, associ\u00e9 \u00e0 une condition 'if' pour filtrer les \u00e9l\u00e9ments. C'est un exemple \u00e9l\u00e9mentaire de filtrage et comptage en Python."}
{"language": "Python", "level": "BEGINNER", "theme": "Contr\u00f4le de flux", "snippet": "values = [0, 1, 2, 3, 4]\ni = 0\nwhile i < len(values):\n    if values[i] % 2 == 0:\n        i += 1\n    else:\n        break\nprint(i)", "choices": ["5", "3", "2", "4"], "answer_id": 2, "explanation": "La boucle 'while' parcourt la liste tant que l'indice 'i' est inf\u00e9rieur \u00e0 la longueur. Si l'\u00e9l\u00e9ment est pair (reste modulo 2 nul), on incr\u00e9mente 'i'. Sinon, on sort de la boucle avec 'break'. Ici, \u00e9l\u00e9ments 0 et 2 sont pairs, puis \u00e0 l'indice 3 la valeur est 3, impair, la boucle s'arr\u00eate. 'i' vaut 2, qui est affich\u00e9.\n\nCe snippet illustre l'utilisation de la boucle 'while' combin\u00e9e \u00e0 un contr\u00f4le conditionnel et \u00e0 l'instruction 'break' pour interrompre pr\u00e9matur\u00e9ment l'it\u00e9ration selon une condition sp\u00e9cifique."}
{"language": "Python", "level": "BEGINNER", "theme": "Contr\u00f4le de flux", "snippet": "scores = [5, 8, 7]\nmax_score = 0\nfor score in scores:\n    if score > max_score:\n        max_score = score\nprint(max_score)", "choices": ["5", "8", "7", "0"], "answer_id": 1, "explanation": "Le code cherche \u00e0 d\u00e9terminer le score maximum dans la liste 'scores'. Initialis\u00e9 \u00e0 0, 'max_score' est remplac\u00e9 chaque fois qu'un 'score' plus grand est trouv\u00e9. 5 remplace 0, puis 8 remplace 5, 7 ne remplace pas car inf\u00e9rieur \u00e0 8. \u00c0 la fin, 'max_score' vaut 8.\n\nCe sch\u00e9ma montre l'usage d'une boucle 'for' combin\u00e9e \u00e0 des conditions pour extraire un maximum, un patron fondamental en programmation pour parcourir et analyser des listes."}
{"language": "Python", "level": "BEGINNER", "theme": "Contr\u00f4le de flux", "snippet": "temps = [25, 18, 22, 19]\ncount = 0\nfor t in temps:\n    if t > 20:\n        count += 1\n    else:\n        count += 2\nprint(count)", "choices": ["7", "8", "6", "5"], "answer_id": 1, "explanation": "Pour chaque temp\u00e9rature, le code ajoute 1 \u00e0 'count' si la temp\u00e9rature est strictement sup\u00e9rieure \u00e0 20, sinon ajoute 2. Les temp\u00e9ratures 25 et 22 >20 donc +1,+1. Les valeurs 18 et 19 \u226420 donc +2,+2. Total: 1+2+1+2=6 ? Mais en ordre 25 +1 (1),18 +2 (3),22 +1 (4),19 +2 (6). Le total est 6, donc la bonne r\u00e9ponse est 6.\n\nPardon, rev\u00e9rifions. 25>20 => count=1; 18<=20 => count=3; 22>20 => count=4; 19<=20 => count=6. La r\u00e9ponse correcte est 6.\n\nLe snippet illustre une boucle avec un 'if...else' pour augmenter un compteur selon des crit\u00e8res. C'est une mani\u00e8re simple d'appliquer des r\u00e8gles diff\u00e9rentes selon conditions dans un flux."}
{"language": "Python", "level": "BEGINNER", "theme": "Contr\u00f4le de flux", "snippet": "numbers = [1, 2, 3, 4]\nresult = 0\nfor n in numbers:\n    if n % 2 == 0:\n        result += n\nprint(result)", "choices": ["6", "10", "4", "9"], "answer_id": 0, "explanation": "La boucle 'for' traverse 'numbers'. L'instruction 'if' v\u00e9rifie si 'n' est pair (n modulo 2 \u00e9gal \u00e0 0). Les nombres pairs sont 2 et 4. Leurs sommes donne 6, ce qui est affich\u00e9.\n\nCette construction d\u00e9montre la combinaison de la structure conditionnelle 'if' avec la boucle 'for' pour filtrer et accumuler des valeurs r\u00e9pondant \u00e0 une condition simple (pair ou impair). C'est un usage \u00e9l\u00e9mentaire des contr\u00f4les de flux en Python."}
{"language": "Python", "level": "BEGINNER", "theme": "Contr\u00f4le de flux", "snippet": "temps = [30, 25, 20]\ntotal = 0\nidx = 0\nwhile idx < len(temps):\n    if temps[idx] >= 25:\n        total += 1\n    idx += 1\nprint(total)", "choices": ["2", "3", "1", "0"], "answer_id": 0, "explanation": "La boucle 'while' parcourt les indices de la liste 'temps'. Pour chaque \u00e9l\u00e9ment >= 25, elle incr\u00e9mente 'total'. Les valeurs 30 et 25 remplissent la condition, soit 2 \u00e9l\u00e9ments. La sortie est donc 2.\n\nCe code montre la mise en place d'une boucle 'while' traditionnelle avec un compteur manuel d'indice, coupl\u00e9e \u00e0 un test conditionnel. Ce pattern est basique mais fondamental pour contr\u00f4ler des donn\u00e9es pas forc\u00e9ment de mani\u00e8re s\u00e9quentielle ou avec une boucle 'for'."}
{"language": "Python", "level": "BEGINNER", "theme": "Contr\u00f4le de flux", "snippet": "sales = [100, 200, 150]\ndiscounted = []\nfor s in sales:\n    if s > 150:\n        discounted.append(s * 0.9)\n    else:\n        discounted.append(s)\nprint(discounted)", "choices": ["[100, 180.0, 150]", "[90.0, 180.0, 135.0]", "[100, 200, 150]", "[100, 180, 150]"], "answer_id": 0, "explanation": "Le code traverse la liste 'sales'. Pour chaque vente sup\u00e9rieure \u00e0 150, il applique une remise de 10% (multiplication par 0.9) et ajoute le r\u00e9sultat \u00e0 'discounted'. Sinon, il ajoute la valeur sans changement. 200 >150 donc 180.0, 100 et 150 restent inchang\u00e9s, la liste finale est [100, 180.0, 150].\n\nCe snippet illustre l'usage d'une boucle 'for' pour transformer une liste conditionnellement avec un 'if...else'. Le r\u00e9sultat est construit dans une autre liste, une technique courante pour cr\u00e9er une nouvelle collection selon certaines r\u00e8gles."}
{"language": "Python", "level": "BEGINNER", "theme": "Contr\u00f4le de flux", "snippet": "attempts = [3, 5, 8]\nsuccess = False\nfor a in attempts:\n    if a == 5:\n        success = True\n        break\nprint(success)", "choices": ["True", "False", "3", "5"], "answer_id": 0, "explanation": "La boucle 'for' parcourt 'attempts'. D\u00e8s qu'elle rencontre la valeur 5, elle met 'success' \u00e0 True et sort de la boucle avec 'break'. Ainsi, 'success' vaut True au print.\n\nCe mod\u00e8le montre l'utilisation de l'instruction 'break' qui termine pr\u00e9matur\u00e9ment une boucle d\u00e8s qu'une condition est remplie, ici pour d\u00e9tecter rapidement la pr\u00e9sence d'une valeur recherch\u00e9e."}
