snippet_db_json = [
    {
        "snippet": 'print("".join(sorted("bca")))',
        "reponses": ['"abc"', '"bca"', '["a", "b", "c"]', "TypeError"],
        "bonne_reponse_id": 0,
        "explication": "sorted() retourne une liste triée de caractères. ''.join(...) recompose une chaîne. Ici: \"abc\".",
        "explication": "La fonction `sorted(\"bca\")` retourne une liste de caractères triés : `['a', 'b', 'c']`. Ensuite, `\"\".join(...)` permet de concaténer ces caractères en une seule chaîne. Ainsi, le résultat affiché est `\"abc\"`.\n\n **Résumé** : On trie les lettres puis on les assemble en une chaîne.",
    },
    {
        "snippet": "def f(x=[]):\n    x.append(1)\n    return len(x)\n\nf()\nf()\nprint(f())",
        "reponses": ["1", "2", "3", "TypeError"],
        "bonne_reponse_id": 2,
        "explication": "L’argument par défaut liste est partagé entre appels (mutable). Après trois appels successifs, sa longueur vaut 3.",
        "explication": "En Python, les arguments par défaut sont évalués une seule fois lors de la définition de la fonction. Ici, la liste `x` est partagée entre tous les appels à `f()`. À chaque appel, on ajoute `1` à la même liste. Après trois appels, la liste contient trois éléments, donc `len(x)` vaut `3`.\n\n **Attention** : Ce comportement peut causer des bugs subtils avec des objets mutables.",
    },
    {
        "snippet": 'try:\n    {}["x"]\nexcept Exception as e:\n    print(type(e).__name__)',
        "reponses": ["KeyError", "NameError", "TypeError", "No exception"],
        "bonne_reponse_id": 0,
        "explication": "Accéder à une clé inexistante sur un dict lève un KeyError. On affiche le nom de l’exception.",
        "explication": "Accéder à une clé qui n'existe pas dans un dictionnaire (`{}`) provoque une exception de type `KeyError`. Le bloc `except` capture cette exception et affiche son nom avec `type(e).__name__`, donc le programme affiche `\"KeyError\"`.\n",
    },
    {
        "snippet": 's = "python"\nprint(s[::-2])',
        "reponses": ['"nhy"', '"nhto"', '"nhtp"', '"pyt"'],
        "bonne_reponse_id": 0,
        "explication": "Slicing avec step -2 parcourt les indices 5,3,1 de \"python\" → 'n','h','y' donc \"nhy\".",
        "explication": "Le slicing `[::-2]` parcourt la chaîne en partant de la fin, en sautant un caractère à chaque fois (step -2). Les indices pris sont 5, 3, 1, ce qui correspond aux lettres `'n'`, `'h'`, `'y'`. Le résultat affiché est donc `\"nhy\"`.\n",
    },
    {
        "snippet": "try:\n    a = (1, 2, 3)\n    a[0] = 9\nexcept Exception as e:\n    print(type(e).__name__)",
        "reponses": ["IndexError", "TypeError", "ValueError", "No exception"],
        "bonne_reponse_id": 1,
        "explication": "Les tuples sont immuables; tenter d’assigner un élément lève TypeError.",
        "explication": "Les tuples en Python sont immuables, c'est-à-dire qu'on ne peut pas modifier leurs éléments après leur création. Tenter d'assigner une nouvelle valeur à un élément (`a[0] = 9`) lève une exception de type `TypeError`, qui est capturée et affichée.\n",
    },
    {
        "snippet": "print(5 // 2)",
        "reponses": ["2", "2.5", "3", "TypeError"],
        "bonne_reponse_id": 0,
        "explication": "// est la division entière (floor) sur des int: 5 // 2 = 2.",
        "explication": "L'opérateur `//` effectue une division entière (floor division) en Python. Il retourne le quotient sans la partie décimale. Ici, `5 // 2` donne `2`.\n",
    },
    {
        "snippet": 'print(bool("False"))',
        "reponses": ["True", "False", '"False"', "TypeError"],
        "bonne_reponse_id": 0,
        "explication": 'Toute chaîne non vide est évaluée à True en booléen, même "False".',
        "explication": "En Python, toute chaîne non vide est évaluée à `True` lorsqu'on la convertit en booléen, même si son contenu est `\"False\"`. Seule la chaîne vide `\"\"` est évaluée à `False`.\n",
    },
    {
        "snippet": "x = 5\nlst = [x for x in range(3)]\nprint(x)",
        "reponses": ["5", "2", "3", "NameError"],
        "bonne_reponse_id": 0,
        "explication": "Depuis Python 3, la compréhension a sa portée locale; elle n’écrase pas la variable x externe. On affiche 5.",
        "explication": "Depuis Python 3, la variable utilisée dans une compréhension de liste (`x` dans `[x for x in range(3)]`) a une portée locale à la compréhension. Elle n'écrase pas la variable `x` définie à l'extérieur. Ainsi, `print(x)` affiche la valeur externe, soit `5`.\n",
    },
    {
        "snippet": 'd = {"a": 1}\nprint(d.get("b", d.get("a") + 1))',
        "reponses": ["1", "2", "None", "KeyError"],
        "bonne_reponse_id": 1,
        "explication": 'get("b", défaut) retourne le défaut si la clé n’existe pas. Ici défaut = d.get("a") + 1 = 2.',
        "explication": "La méthode `get(\"b\", défaut)` retourne la valeur associée à la clé `\"b\"` si elle existe, sinon le défaut. Ici, `\"b\"` n'existe pas, donc le défaut est calculé : `d.get(\"a\") + 1` soit `1 + 1 = 2`. Le résultat affiché est donc `2`.\n",
    },
    {
        "snippet": "def gen():\n    yield 10\n    return 7\n\ng = gen()\ntry:\n    next(g)\n    next(g)\nexcept StopIteration as e:\n    print(e.value)",
        "reponses": ["10", "7", "None", "StopIteration"],
        "bonne_reponse_id": 1,
        "explication": "À la fin d’un générateur, return X lève StopIteration avec value=X. On capture puis on affiche 7.",
        "explication": "Lorsqu'un générateur termine avec une instruction `return X`, cela lève une exception `StopIteration` dont l'attribut `value` contient la valeur retournée (`X`). Ici, après avoir consommé le seul `yield`, le second `next(g)` lève `StopIteration` avec `value=7`, qui est capturé et affiché.\n",
    },
]
